<!doctype html>
<html lang="zh">
<head>
  <meta charset="UTF-8" />
  <meta http-equiv="Content-Security-Policy"
        content="default-src 'self' http://127.0.0.1:8787;
                 script-src 'self' 'unsafe-inline';
                 style-src 'self' 'unsafe-inline';
                 img-src 'self' data:;
                 connect-src 'self' http://127.0.0.1:8787;">
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Engine External</title>
  <style>
    body { font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; margin: 0; background: #0b0f17; color: #e7eefc; }
    header { padding: 14px 18px; display:flex; align-items:center; justify-content:space-between; border-bottom: 1px solid rgba(255,255,255,.08); }
    .badge { font-size: 12px; opacity: .75; }
    .wrap { display:grid; grid-template-columns: 380px 1fr; height: calc(100vh - 52px); }
    .panel { border-right: 1px solid rgba(255,255,255,.08); padding: 14px; overflow:auto; }
    .main { padding: 14px; display:flex; flex-direction:column; gap:10px; }
    .card { background: rgba(255,255,255,.06); border: 1px solid rgba(255,255,255,.08); border-radius: 14px; padding: 12px; }
    label { display:block; font-size: 12px; opacity: .85; margin-bottom: 6px; }
    input, textarea { width:100%; box-sizing:border-box; border-radius: 10px; border:1px solid rgba(255,255,255,.14); background: rgba(0,0,0,.25); color:#e7eefc; padding: 10px; outline:none; }
    textarea { min-height: 90px; resize: vertical; }
    button { cursor:pointer; border-radius: 12px; border:1px solid rgba(255,255,255,.14); background: rgba(255,255,255,.08); color:#e7eefc; padding: 10px 12px; }
    button:hover { background: rgba(255,255,255,.12); }
    .chatlog { flex:1; overflow:auto; display:flex; flex-direction:column; gap:10px; }
    .bubble { padding: 10px 12px; border-radius: 14px; border:1px solid rgba(255,255,255,.10); white-space: pre-wrap; }
    .u { background: rgba(80,120,255,.12); align-self:flex-end; max-width: 76%; }
    .a { background: rgba(255,255,255,.06); align-self:flex-start; max-width: 76%; }
    .muted { opacity:.75; font-size:12px; }
    
    /* Memory Panel Styles */
    .memory-item { background: rgba(255,255,255,.04); border: 1px solid rgba(255,255,255,.06); border-radius: 8px; padding: 6px 8px; margin-bottom: 4px; transition: all 0.2s; }
    .memory-item:hover { background: rgba(255,255,255,.08); border-color: rgba(255,255,255,.12); }
    .memory-content { font-size: 12px; margin-bottom: 3px; line-height: 1.3; }
    .memory-meta { font-size: 10px; opacity: 0.6; display: flex; gap: 6px; flex-wrap: wrap; }
    .memory-tag { background: rgba(80,120,255,.2); padding: 1px 4px; border-radius: 3px; font-size: 9px; }
    .memory-tag.emotion { background: rgba(255,100,100,.2); }
    .memory-tag.topic { background: rgba(100,200,100,.2); }
    .entity-item { background: rgba(255,200,100,.1); border: 1px solid rgba(255,200,100,.2); border-radius: 6px; padding: 5px 6px; margin-bottom: 4px; }
    .entity-name { font-weight: 600; font-size: 12px; }
    .entity-type { font-size: 10px; opacity: 0.6; }
    .relation-item { font-size: 11px; padding: 4px 6px; background: rgba(100,200,255,.1); border-radius: 4px; margin-bottom: 3px; }
    .tab-buttons { display: flex; gap: 6px; margin-bottom: 10px; }
    .tab-btn { flex: 1; text-align: center; padding: 8px; border-radius: 8px; background: rgba(255,255,255,.04); border: 1px solid rgba(255,255,255,.08); cursor: pointer; font-size: 12px; }
    .tab-btn.active { background: rgba(80,120,255,.2); border-color: rgba(80,120,255,.4); }
    .stat-row { display: flex; justify-content: space-between; padding: 6px 0; border-bottom: 1px solid rgba(255,255,255,.06); font-size: 12px; }
    .importance-bar { height: 2px; background: rgba(255,255,255,.1); border-radius: 1px; overflow: hidden; margin-top: 2px; }
    .importance-fill { height: 100%; background: linear-gradient(90deg, #4080ff, #80c0ff); }
    /* Modal window styles */
    .modal { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,.7); z-index: 1000; align-items: center; justify-content: center; }
    .modal.show { display: flex; }
    .modal-content { background: #0b0f17; border: 1px solid rgba(255,255,255,.12); border-radius: 16px; width: 90%; height: 90%; max-width: 900px; display: flex; flex-direction: column; box-shadow: 0 20px 60px rgba(0,0,0,.6); }
    .modal-header { display: flex; justify-content: space-between; align-items: center; padding: 16px 20px; border-bottom: 1px solid rgba(255,255,255,.08); }
    .modal-header h2 { margin: 0; font-size: 18px; font-weight: 700; }
    .modal-close { cursor: pointer; font-size: 24px; opacity: 0.6; }
    .modal-close:hover { opacity: 1; }
    .modal-body { flex: 1; overflow-y: auto; overflow-x: hidden; padding: 16px 20px; }
    /* Custom scrollbar styles (modal only) */
    .modal-body::-webkit-scrollbar { width: 8px; }
    .modal-body::-webkit-scrollbar-track { background: rgba(255,255,255,.04); border-radius: 4px; }
    .modal-body::-webkit-scrollbar-thumb { background: rgba(80,120,255,.4); border-radius: 4px; }
    .modal-body::-webkit-scrollbar-thumb:hover { background: rgba(80,120,255,.6); }
    
    /* Global scrollbar styles for all elements */
    ::-webkit-scrollbar { width: 10px; height: 10px; }
    ::-webkit-scrollbar-track { background: rgba(255,255,255,.02); }
    ::-webkit-scrollbar-thumb {
      background: linear-gradient(180deg, rgba(80,120,255,.4) 0%, rgba(100,150,255,.3) 100%);
      border-radius: 5px;
      border: 2px solid rgba(255,255,255,.01);
    }
    ::-webkit-scrollbar-thumb:hover {
      background: linear-gradient(180deg, rgba(80,120,255,.6) 0%, rgba(100,150,255,.5) 100%);
    }
    ::-webkit-scrollbar-corner { background: rgba(255,255,255,.01); }
    
    /* Scrollbar for panel */
    .panel::-webkit-scrollbar { width: 8px; }
    .panel::-webkit-scrollbar-track { background: rgba(255,255,255,.02); }
    .panel::-webkit-scrollbar-thumb {
      background: linear-gradient(180deg, rgba(80,120,255,.35) 0%, rgba(100,150,255,.25) 100%);
      border-radius: 4px;
    }
    .panel::-webkit-scrollbar-thumb:hover {
      background: linear-gradient(180deg, rgba(80,120,255,.55) 0%, rgba(100,150,255,.45) 100%);
    }
    
    /* Scrollbar for chatlog */
    .chatlog::-webkit-scrollbar { width: 8px; }
    .chatlog::-webkit-scrollbar-track { background: rgba(255,255,255,.02); }
    .chatlog::-webkit-scrollbar-thumb {
      background: linear-gradient(180deg, rgba(80,120,255,.35) 0%, rgba(100,150,255,.25) 100%);
      border-radius: 4px;
    }
    .chatlog::-webkit-scrollbar-thumb:hover {
      background: linear-gradient(180deg, rgba(80,120,255,.55) 0%, rgba(100,150,255,.45) 100%);
    }
    /* Conversation list styles */
    .conversation-item { background: rgba(255,255,255,.04); border: 1px solid rgba(255,255,255,.08); border-radius: 10px; padding: 12px 14px; margin-bottom: 8px; cursor: pointer; transition: all 0.2s; display: flex; justify-content: space-between; align-items: flex-start; }
    .conversation-item:hover { background: rgba(80,120,255,.15); border-color: rgba(80,120,255,.3); }
    .conversation-item-content { flex: 1; min-width: 0; }
    .conversation-item-actions { display: flex; gap: 8px; opacity: 0; transition: opacity 0.2s; margin-left: 8px; }
    .conversation-item:hover .conversation-item-actions { opacity: 1; }
    .delete-btn { padding: 6px 10px; background: rgba(255,100,100,.15); border: 1px solid rgba(255,100,100,.3); color: #ff6464; border-radius: 6px; font-size: 12px; cursor: pointer; transition: all 0.2s; white-space: nowrap; }
    .delete-btn:hover { background: rgba(255,100,100,.25); border-color: rgba(255,100,100,.5); }
    .conversation-title { font-size: 14px; font-weight: 600; margin-bottom: 4px; line-height: 1.4; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .conversation-meta { font-size: 11px; opacity: 0.6; display: flex; gap: 12px; }
    .conversation-preview { margin-top: 8px; padding: 10px; background: rgba(0,0,0,.2); border-radius: 8px; max-height: 300px; overflow-y: auto; }
    .preview-message { padding: 8px 10px; margin-bottom: 6px; border-radius: 8px; font-size: 13px; line-height: 1.5; }
    .preview-message.user { background: rgba(80,120,255,.15); margin-left: 20%; }
    .preview-message.assistant { background: rgba(255,255,255,.08); margin-right: 20%; }
    .preview-message .role { font-size: 10px; opacity: 0.6; margin-bottom: 4px; text-transform: uppercase; }
  </style>
</head>
<body>
  <header>
    <div>
      <div style="font-weight:700;">Engine External</div>
      <div class="badge">Local-only â€¢ Backend: 127.0.0.1:8787 â€¢ Version <span id="ver"></span></div>
    </div>
    <div class="badge">Tip: Start backend first, then open chat.</div>
  </header>

  <div class="wrap">
    <aside class="panel">
      <div class="card">
        <div style="display:flex; justify-content:space-between; align-items:center; cursor:pointer;" id="settings-toggle">
          <div style="font-weight:700;">Settings</div>
          <span id="settings-arrow">â–¼</span>
        </div>
        <div id="settings-content" style="display:none; margin-top:10px;">
          <div class="muted" style="margin-bottom:10px;">Enter OpenAI-compatible base_url / api_key / model (stored locally only).</div>

          <label>Base URL (e.g. https://api.openai.com)</label>
          <input id="base_url" placeholder="https://api.openai.com" />

          <label style="margin-top:10px;">API Key (leave empty to keep existing key)</label>
          <input id="api_key" type="password" placeholder="Leave empty to skip" />

          <label style="margin-top:10px;">Model</label>
          <select id="model" style="width:100%; box-sizing:border-box; border-radius:10px; border:1px solid rgba(255,255,255,.14); background:rgba(0,0,0,.25); color:#e7eefc; padding:10px; margin-bottom:8px;">
            <option value="">-- Select Model --</option>
            <optgroup label="OpenAI Models">
              <option value="">Loading models from OpenAI...</option>
            </optgroup>
            <optgroup label="Custom">
              <option value="custom">Custom Model...</option>
            </optgroup>
          </select>
          <button id="refresh-models-btn" style="width:100%; padding:10px 16px; border-radius:10px; border:1px solid rgba(255,255,255,.14); background:rgba(0,0,0,.25); color:#e7eefc; cursor:pointer; margin-bottom:10px;">Refresh Models</button>
          <div id="model-status" class="muted" style="font-size:12px; margin-bottom:10px; display:none;"></div>
          <input id="model_custom" placeholder="Enter custom model name" style="display:none; margin-top:6px;" />

          <label style="margin-top:10px;">Max Input Tokens (context limit)</label>
          <input id="max_input_tokens" type="number" placeholder="2000" min="100" max="128000" />
          <div id="system_prompt_tokens_info" class="muted" style="font-size:12px; margin-top:2px;"></div>

          <label style="margin-top:10px;">Max Output Tokens (response limit)</label>
          <input id="max_output_tokens" type="number" placeholder="800" min="100" max="32000" />

          <label style="margin-top:10px;">Temperature (0.0 = deterministic, 1.0 = creative)</label>
          <input id="temperature" type="number" placeholder="0.7" min="0" max="2" step="0.1" />

          <div style="margin-top:12px; display:flex; align-items:center; gap:8px;">
            <input id="dev_mode" type="checkbox" style="width:auto; margin:0;" />
            <label for="dev_mode" style="margin:0; cursor:pointer;">Developer Mode (show token usage)</label>
          </div>

          <div style="display:flex; gap:10px; margin-top:12px;">
            <button id="save">Save</button>
            <button id="health">Test Backend</button>
          </div>
        </div>
        <div id="status" class="muted" style="margin-top:10px;"></div>
      </div>

      <!-- System Prompt Panel -->
      <div class="card" style="margin-top:12px;">
        <div style="display:flex; justify-content:space-between; align-items:center;">
          <div style="font-weight:700;">System Prompt</div>
        </div>
        <button id="open-system-prompt-window" style="width:100%; margin-top:10px; padding:12px; font-size:14px;">Edit System Prompt</button>
      </div>

      <!-- Conversation History Panel -->
      <div class="card" style="margin-top:12px;">
        <div style="display:flex; justify-content:space-between; align-items:center;">
          <div style="font-weight:700;">Chat History</div>
        </div>
        <button id="open-conversations-window" style="width:100%; margin-top:10px; padding:12px; font-size:14px;">Load Conversation History</button>
      </div>

      <!-- Memory Panel (Modal/Popup Mode) -->
      <div class="card" style="margin-top:12px;">
        <div style="display:flex; justify-content:space-between; align-items:center;">
          <div style="font-weight:700;">Memory</div>
        </div>
        <button id="open-memory-window" style="width:100%; margin-top:10px; padding:12px; font-size:14px;">Open Memory Window</button>
      </div>

      <!-- User Profile Card -->
      <div class="card" style="margin-top:12px;">
        <div style="display:flex; justify-content:space-between; align-items:center; cursor:pointer;" id="profile-toggle">
          <div style="font-weight:700;">ğŸ‘¤ User Profile</div>
          <span id="profile-arrow" style="font-size:10px;">â–¶</span>
        </div>
        <div id="profile-content" style="display:none; margin-top:10px;">
          <label>Name / Nickname</label>
          <input id="user_name" placeholder="e.g. Alice, John..." />
          
          <label style="margin-top:8px;">Age</label>
          <input id="user_age" type="number" placeholder="e.g. 25" min="1" max="150" />
          
          <label style="margin-top:8px;">Gender</label>
          <select id="user_gender" style="width:100%; box-sizing:border-box; border-radius:10px; border:1px solid rgba(255,255,255,.14); background:rgba(0,0,0,.25); color:#e7eefc; padding:10px;">
            <option value="">-- Not specified --</option>
            <option value="Male">Male</option>
            <option value="Female">Female</option>
            <option value="Other">Other</option>
          </select>
          
          <label style="margin-top:8px;">Occupation</label>
          <input id="user_occupation" placeholder="e.g. Software Engineer..." />
          
          <label style="margin-top:8px;">Location</label>
          <input id="user_location" placeholder="e.g. Beijing, China..." />
          
          <label style="margin-top:8px;">Short Bio</label>
          <textarea id="user_bio" placeholder="Tell me about yourself..." style="min-height:60px;"></textarea>
          
          <button id="save-profile" style="width:100%; margin-top:10px; padding:10px 12px; background:rgba(80,120,255,.3); border-color:rgba(80,120,255,.4); font-weight:500;">Save Profile</button>
        </div>
      </div>
    </aside>

    <!-- System Prompt Modal Window -->
    <div id="system-prompt-modal" class="modal">
      <div class="modal-content" style="max-width: 700px;">
        <div class="modal-header">
          <h2>System Prompt</h2>
          <span class="modal-close" id="close-system-prompt-modal">&times;</span>
        </div>
        <div class="modal-body">
          <div class="muted" style="margin-bottom:12px; font-size:12px;">Choose an AI personality preset or create a custom one</div>
          
          <!-- Template Selection -->
          <div style="margin-bottom:16px;">
            <label style="font-size:12px; margin-bottom:6px; display:block; font-weight:600;">AI Personality</label>
            <select id="system-prompt-template-select" style="width:100%; padding:10px; border-radius:6px; border:1px solid rgba(255,255,255,.14); background:rgba(0,0,0,.25); color:#e7eefc; font-size:13px; outline:none; cursor:pointer;">
            </select>
            <div id="template-status" class="muted" style="margin-top:6px; font-size:11px;"></div>
          </div>
          
          <!-- Custom Prompt Input (shown when custom selected) -->
          <div id="custom-prompt-section" style="display:none;">
            <label style="font-size:12px; margin-bottom:6px; display:block;">Your Custom Prompt</label>
            <textarea id="system-prompt-input" placeholder="Enter your custom AI personality here..." style="width:100%; min-height:300px; max-height:500px; font-size:13px; box-sizing:border-box; border-radius:8px; border:1px solid rgba(255,255,255,.14); background:rgba(0,0,0,.25); color:#e7eefc; padding:12px; outline:none; font-family: monospace; resize: vertical;"></textarea>
            
            <label style="font-size:12px; margin-bottom:6px; display:block; margin-top:12px;">Name this personality (optional)</label>
            <input id="custom-prompt-name" type="text" placeholder="e.g., My Friendly Bot" style="width:100%; padding:10px; border-radius:6px; border:1px solid rgba(255,255,255,.14); background:rgba(0,0,0,.25); color:#e7eefc; font-size:13px; outline:none; box-sizing:border-box;">
            
            <div style="display:flex; gap:10px; margin-top:12px;">
              <button id="save-system-prompt" style="flex:1; padding:10px; border-radius:8px; border:1px solid rgba(255,255,255,.14); background:rgba(80,120,255,.2); color:#e7eefc; font-size:13px; cursor:pointer;">Save</button>
              <button id="reset-system-prompt" style="flex:1; padding:10px; border-radius:8px; border:1px solid rgba(255,255,255,.08); color:#e7eefc; font-size:13px; cursor:pointer;">Clear</button>
            </div>
          </div>
          
          <div id="system-prompt-status" class="muted" style="margin-top:10px; font-size:11px;"></div>
        </div>
      </div>
    </div>

    <!-- Conversations Modal Window -->
    <div id="conversations-modal" class="modal">
      <div class="modal-content" style="max-width: 700px;">
        <div class="modal-header">
          <h2>Conversation History</h2>
          <span class="modal-close" id="close-conversations-modal">&times;</span>
        </div>
        <div class="modal-body">
          <!-- Search bar and controls -->
          <div style="margin-bottom:12px; display:flex; gap:8px; align-items:center;">
            <input id="conversation-search" type="text" placeholder="Search conversations..." style="flex:1; box-sizing:border-box; border-radius:10px; border:1px solid rgba(255,255,255,.14); background:rgba(0,0,0,.25); color:#e7eefc; padding:10px; outline:none;" />
            <button id="reload-conversations-btn" title="Reload from conversations.json" style="padding:10px 12px; font-size:12px; background:rgba(255,180,80,.2); border-color:rgba(255,180,80,.4); white-space:nowrap;">ğŸ”„ Reload</button>
          </div>
          
          <!-- Conversation list -->
          <div id="conversation-list" style="max-height: 55vh; overflow-y: auto;">
            <div class="muted" style="text-align:center; padding:30px;">Loading conversations...</div>
          </div>
          
          <!-- Status -->
          <div id="conversation-status" class="muted" style="margin-top:10px; font-size:11px;"></div>
        </div>
      </div>
    </div>

    <!-- Custom Confirm Dialog -->
    <div id="confirm-dialog" class="modal" style="display:none; z-index:9999;">
      <div class="modal-content" style="max-width: 260px; max-height: 100px; background:rgba(20,30,60,.95); border:1px solid rgba(80,120,255,.3); display:flex; flex-direction:column;">
        <div class="modal-body" style="padding:10px; flex:1; display:flex; flex-direction:column; justify-content:space-between;">
          <h3 id="confirm-title" style="display:none;"></h3>
          <p id="confirm-message" style="margin:0 0 8px 0; font-size:13px; color:rgba(231,238,252,.9); line-height:1.3; text-align:center;"></p>
          <div style="display:flex; gap:8px; justify-content:center;">
            <button id="confirm-cancel" style="padding:6px 16px; border-radius:4px; border:1px solid rgba(255,255,255,.14); background:rgba(255,255,255,.08); color:#e7eefc; font-size:12px; cursor:pointer;">å–æ¶ˆ</button>
            <button id="confirm-ok" style="padding:6px 16px; border-radius:4px; border:1px solid rgba(80,120,255,.4); background:rgba(80,120,255,.3); color:#e7eefc; font-size:12px; cursor:pointer;">ç¡®è®¤</button>
          </div>
        </div>
      </div>
    </div>

    <!-- Memory Modal Window -->

    <div id="memory-modal" class="modal">
      <div class="modal-content">
        <div class="modal-header">
          <h2>Memory</h2>
          <span class="modal-close" id="close-memory-modal">&times;</span>
        </div>
        <div class="modal-body">
          <!-- Plugin Selection (Hidden, always using vector memory) -->
          <input type="hidden" id="memory-plugin-select" value="vector">
          <div id="plugin-info" class="muted" style="font-size:11px; padding:6px; background:rgba(255,255,255,.04); border-radius:4px; margin-bottom:8px; display:none;"></div>
          <div id="plugin-features" style="display:none; gap:4px; flex-wrap:wrap;"></div>
          
          <!-- Tab Switching -->
          <div class="tab-buttons">
            <div class="tab-btn active" data-tab="memories">Memories</div>
            <div class="tab-btn" data-tab="entities">Entities</div>
            <div class="tab-btn" data-tab="stats">Stats</div>
            <button id="refresh-memory" style="padding:8px 12px; font-size:12px; flex:0.5;">Refresh</button>
          </div>

          <!-- Memory List -->
          <div id="memories-tab" class="tab-content">
            <!-- Core Memory -->
            <div style="margin-bottom:16px;">
              <div style="font-weight:600; font-size:12px; margin-bottom:8px; color:#80d8ff;">â­ Core Memory</div>
              <div id="core-memory-list" style="background:rgba(0,0,0,.2); border-radius:6px; padding:8px; min-height:60px; max-height:150px; overflow-y:auto; border:1px solid rgba(128,216,255,.2);">
                <div class="muted" style="text-align:center; padding:20px; font-size:12px;">No core memories yet</div>
              </div>
            </div>
            
            <!-- Memory Library -->
            <div>
              <div style="font-weight:600; font-size:12px; margin-bottom:8px; color:#b3e5fc;">ğŸ“š Memory Library</div>
              
              <!-- Memory list -->
              <div id="memory-library-list" style="background:rgba(0,0,0,.2); border-radius:6px; padding:8px; min-height:60px; max-height:200px; overflow-y:auto; border:1px solid rgba(179,229,252,.2);">
                <div class="muted" style="text-align:center; padding:20px; font-size:12px;">Click refresh to load memories...</div>
              </div>
            </div>
          </div>

          <!-- Entity List -->
          <div id="entities-tab" class="tab-content" style="display:none;">
            <div id="entity-list">
              <div class="muted" style="text-align:center; padding:30px;">No entities found...</div>
            </div>
            <div style="margin-top:12px;">
              <div style="font-weight:600; font-size:12px; margin-bottom:8px;">Knowledge Graph</div>
              <div id="relation-list">
                <div class="muted" style="text-align:center; padding:15px;">No relationships...</div>
              </div>
            </div>
          </div>

          <!-- Statistics -->
          <div id="stats-tab" class="tab-content" style="display:none;">
            <div id="memory-stats">
              <div class="muted" style="text-align:center; padding:30px;">Loading...</div>
            </div>
          </div>
          
          <!-- Add Memory -->
          <div style="margin-top:16px; padding-top:12px; border-top:1px solid rgba(255,255,255,.08);">
            <div style="font-weight:600; font-size:13px; margin-bottom:8px;">Add Memory</div>
            <textarea id="new-memory" placeholder="Enter memory content..." style="width:100%; min-height:60px; font-size:12px; box-sizing:border-box; border-radius:8px; border:1px solid rgba(255,255,255,.14); background:rgba(0,0,0,.25); color:#e7eefc; padding:8px; outline:none;"></textarea>
            <div style="display:flex; gap:6px; margin-top:8px;">
              <button id="add-memory" style="flex:1; padding:8px; border-radius:8px; border:1px solid rgba(255,255,255,.14); background:rgba(80,120,255,.2); color:#e7eefc; font-size:12px; cursor:pointer;">Add</button>
              <button id="auto-select-core" style="flex:1; padding:8px; border-radius:8px; border:1px solid rgba(255,200,100,.3); background:rgba(255,200,100,.15); color:#e7eefc; font-size:12px; cursor:pointer;" title="Let AI select important memories for Core">ğŸ¤– Auto Core</button>
              <button id="clear-memory" style="padding:8px 12px; border-radius:8px; border:1px solid rgba(255,255,255,.14); background:rgba(255,80,80,.2); color:#e7eefc; font-size:12px; cursor:pointer;">Clear</button>
            </div>
            <div id="memory-status" class="muted" style="margin-top:8px; font-size:11px;"></div>
          </div>
        </div>
      </div>
    </div>

    <main class="main">
      <!-- Loaded conversation header (top) -->
      <div id="loaded-conv-header" style="display:none; padding:8px 12px; background:rgba(80,120,255,.08); border-bottom:1px solid rgba(80,120,255,.2); border-radius:6px 6px 0 0; margin-bottom:0;">
        <div style="display:flex; gap:8px; align-items:center; font-size:12px;">
          <label style="color:rgba(255,255,255,.6); white-space:nowrap;">Title:</label>
          <input id="loaded-conv-title-header" type="text" placeholder="Conversation title..." style="flex:1; border-radius:4px; border:1px solid rgba(255,255,255,.1); background:rgba(0,0,0,.2); color:#e7eefc; padding:4px 8px; font-size:12px; outline:none;" />
          <span id="loaded-conv-meta-header" class="muted" style="font-size:10px; white-space:nowrap;"></span>
        </div>
      </div>
      
      <div class="chatlog" id="chatlog"></div>

      <div class="card">
        <!-- Loaded conversation footer (bottom) -->
        <div id="loaded-conv-footer" style="display:none; padding:6px 10px; background:rgba(80,120,255,.08); border:1px solid rgba(80,120,255,.2); border-radius:4px; margin-bottom:10px;">
          <div style="display:flex; gap:8px; align-items:center; justify-content:space-between; font-size:11px;">
            <span id="loaded-conv-meta-footer" class="muted"></span>
          </div>
        </div>
        
        <label>Message</label>
        <textarea id="msg" placeholder="Say something... (start backend first)"></textarea>
        <div style="display:flex; gap:10px; margin-top:10px;">
          <button id="send">Send</button>
          <button id="clear">Clear</button>
        </div>
        <div id="meta" class="muted" style="margin-top:10px;"></div>
      </div>
    </main>
  </div>

<script>
  document.getElementById("ver").textContent = (window.aurora && window.aurora.version) ? window.aurora.version : "0.1.0";
  const chatlog = document.getElementById("chatlog");
  const status = document.getElementById("status");
  const meta = document.getElementById("meta");

  // Settings collapse/expand toggle
  document.getElementById("settings-toggle").onclick = () => {
    const content = document.getElementById("settings-content");
    const arrow = document.getElementById("settings-arrow");
    if (content.style.display === "none") {
      content.style.display = "block";
      arrow.textContent = "â–²";
    } else {
      content.style.display = "none";
      arrow.textContent = "â–¼";
    }
  };

  // User Profile collapse/expand toggle
  document.getElementById("profile-toggle").onclick = () => {
    const content = document.getElementById("profile-content");
    const arrow = document.getElementById("profile-arrow");
    if (content.style.display === "none") {
      content.style.display = "block";
      arrow.textContent = "â–¼";
    } else {
      content.style.display = "none";
      arrow.textContent = "â–¶";
    }
  };


  function addBubble(text, who, tokenInfo = null) {
    const div = document.createElement("div");
    div.className = "bubble " + (who === "user" ? "u" : "a");
    div.textContent = text;
    
    // å¦‚æœæ˜¯assistantæ¶ˆæ¯ä¸”å¼€å¯äº†å¼€å‘è€…æ¨¡å¼ï¼Œæ˜¾ç¤ºtokenè¯¦æƒ…
    if (who === "assistant" && devModeEnabled && tokenInfo) {
      const tokenDiv = document.createElement("div");
      tokenDiv.className = "muted";
      tokenDiv.style.cssText = "font-size:11px; margin-top:6px; padding-top:6px; border-top:1px solid rgba(255,255,255,0.1);";
      tokenDiv.innerHTML = `<strong>Token Usage:</strong> prompt=${tokenInfo.prompt_tokens || 0}, completion=${tokenInfo.completion_tokens || 0}, total=${tokenInfo.total_tokens || 0}<br>` +
        `<strong>Estimated:</strong> input=${tokenInfo.estimated_input_tokens || 0}, system_prompt=${tokenInfo.system_prompt_tokens || 0}`;
      div.appendChild(tokenDiv);
    }
    
    chatlog.appendChild(div);
    chatlog.scrollTop = chatlog.scrollHeight;
  }

  // API function to call backend endpoints
  async function api(path, methodOrOptions="GET", body=null) {
    const url = "http://127.0.0.1:8787" + path;
    let opt;
    
    // Support both old format: api(path, method, body) and new format: api(path, options)
    if (typeof methodOrOptions === 'object' && methodOrOptions !== null) {
      // New format: options object
      opt = methodOrOptions;
      if (!opt.headers) opt.headers = {};
      if (!opt.headers['Content-Type']) opt.headers['Content-Type'] = 'application/json';
    } else {
      // Old format: (path, method, body)
      const method = methodOrOptions;
      opt = { method, headers: { "Content-Type": "application/json" } };
      if (body) opt.body = JSON.stringify(body);
    }
    
    const res = await fetch(url, opt);
    if (!res.ok) throw new Error(await res.text());
    return await res.json();
  }

  // ==================== Custom Confirm Dialog ====================
  const confirmDialog = document.getElementById('confirm-dialog');
  const confirmTitle = document.getElementById('confirm-title');
  const confirmMessage = document.getElementById('confirm-message');
  const confirmOkBtn = document.getElementById('confirm-ok');
  const confirmCancelBtn = document.getElementById('confirm-cancel');
  
  async function showConfirm(message) {
    return new Promise((resolve) => {
      confirmTitle.style.display = 'none';
      confirmMessage.textContent = message;
      confirmDialog.style.display = 'flex';
      
      // Create handlers that resolve the promise and cleanup
      const handleOk = () => {
        confirmDialog.style.display = 'none';
        confirmOkBtn.removeEventListener('click', handleOk);
        confirmCancelBtn.removeEventListener('click', handleCancel);
        confirmDialog.removeEventListener('click', handleBackgroundClick);
        resolve(true);
      };
      
      const handleCancel = () => {
        confirmDialog.style.display = 'none';
        confirmOkBtn.removeEventListener('click', handleOk);
        confirmCancelBtn.removeEventListener('click', handleCancel);
        confirmDialog.removeEventListener('click', handleBackgroundClick);
        resolve(false);
      };
      
      const handleBackgroundClick = (e) => {
        if (e.target === confirmDialog) {
          handleCancel();
        }
      };
      
      confirmOkBtn.addEventListener('click', handleOk);
      confirmCancelBtn.addEventListener('click', handleCancel);
      confirmDialog.addEventListener('click', handleBackgroundClick);
    });
  }

  // Global dev mode flag
  let devModeEnabled = false;

  async function loadSettings() {
    try {
      const s = await api("/settings");
      document.getElementById("base_url").value = s.base_url || "";
      document.getElementById("api_key").value = "";
      // Set model dropdown menu
      const modelSelect = document.getElementById("model");
      const modelCustom = document.getElementById("model_custom");
      const savedModel = s.model || "";
      // Check if preset model
      let found = false;
      for (let opt of modelSelect.options) {
        if (opt.value === savedModel) {
          modelSelect.value = savedModel;
          found = true;
          break;
        }
      }
      if (!found && savedModel) {
        modelSelect.value = "custom";
        modelCustom.style.display = "block";
        modelCustom.value = savedModel;
      }
      
      // Load token limits
      document.getElementById("max_input_tokens").value = s.max_input_tokens || "2000";
      document.getElementById("max_output_tokens").value = s.max_output_tokens || "800";
      
      // Load temperature
      document.getElementById("temperature").value = s.temperature !== undefined ? s.temperature : "0.7";
      
      // Load dev mode
      document.getElementById("dev_mode").checked = s.dev_mode || false;
      devModeEnabled = s.dev_mode || false;
      
      // Update system prompt tokens info
      if (s.system_prompt) {
        updateSystemPromptTokensInfo(s.system_prompt);
      }
      
      status.textContent = "Loaded settings (api_key hidden)";
      
      // Try to fetch OpenAI models if we have API key
      if (s.api_key && s.base_url) {
        fetchOpenAIModels(s.api_key, s.base_url);
      }
    } catch (e) {
      status.textContent = "Backend not connected. Please start the backend.";
    }
  }

  // Fetch OpenAI models list via backend
  async function fetchOpenAIModels(apiKey, baseUrl) {
    const statusEl = document.getElementById("model-status");
    const modelSelect = document.getElementById("model");
    
    try {
      statusEl.textContent = "â³ Fetching models...";
      statusEl.style.display = "block";
      
      // Call backend endpoint instead of OpenAI directly (to avoid CORS issues)
      const response = await api("/models/fetch", {
        method: "POST"
      });
      
      if (response.error) {
        let errorMsg = `âŒ ${response.error}`;
        if (response.hint) {
          errorMsg += ` (${response.hint})`;
        }
        statusEl.textContent = errorMsg;
        statusEl.style.display = "block";
        console.error("Error fetching models:", response);
        return;
      }
      
      const models = response.models || [];
      
      if (models.length === 0) {
        statusEl.textContent = "âš ï¸ No models found";
        statusEl.style.display = "block";
        return;
      }
      
      // Clear existing options (except the custom option)
      const openaiOptgroup = modelSelect.querySelector("optgroup[label='OpenAI Models']");
      openaiOptgroup.innerHTML = '';
      
      // Add fetched models
      models.forEach(model => {
        const option = document.createElement("option");
        option.value = model.id;
        option.textContent = model.id;
        openaiOptgroup.appendChild(option);
      });
      
      statusEl.textContent = `âœ“ Loaded ${models.length} models from OpenAI`;
      statusEl.style.display = "block";
      
    } catch (e) {
      statusEl.textContent = `âŒ Failed: ${e.message}`;
      statusEl.style.display = "block";
      console.error("Error fetching models:", e);
    }
  }

  // Refresh models button
  document.getElementById("refresh-models-btn").onclick = async () => {
    const statusEl = document.getElementById("model-status");
    const baseUrl = document.getElementById("base_url").value.trim();
    const apiKey = document.getElementById("api_key").value.trim();
    
    if (!baseUrl) {
      statusEl.textContent = "âŒ Please enter Base URL first";
      statusEl.style.display = "block";
      return;
    }
    
    if (!apiKey) {
      statusEl.textContent = "âŒ Please enter API Key first";
      statusEl.style.display = "block";
      return;
    }
    
    statusEl.textContent = "â³ Fetching models...";
    statusEl.style.display = "block";
    await fetchOpenAIModels(apiKey, baseUrl);
  };

  // Model dropdown: show input when 'custom' is selected
  document.getElementById("model").onchange = () => {
    const modelSelect = document.getElementById("model");
    const modelCustom = document.getElementById("model_custom");
    if (modelSelect.value === "custom") {
      modelCustom.style.display = "block";
      modelCustom.focus();
    } else {
      modelCustom.style.display = "none";
      modelCustom.value = "";
    }
  };

  // Get currently selected model
  function getSelectedModel() {
    const modelSelect = document.getElementById("model");
    const modelCustom = document.getElementById("model_custom");
    if (modelSelect.value === "custom") {
      return modelCustom.value.trim();
    }
    return modelSelect.value;
  }

  document.getElementById("save").onclick = async () => {
    const status = document.getElementById("status");
    try {
      const base_url = document.getElementById("base_url").value.trim();
      const api_key = document.getElementById("api_key").value.trim();
      const model = getSelectedModel();
      const max_input_tokens = parseInt(document.getElementById("max_input_tokens").value) || 2000;
      const max_output_tokens = parseInt(document.getElementById("max_output_tokens").value) || 800;
      const temperature = parseFloat(document.getElementById("temperature").value) || 0.7;
      const dev_mode = document.getElementById("dev_mode").checked;
      
      // è·å–å½“å‰è®¾ç½®ï¼Œä¿ç•™ç”¨æˆ·æœªä¿®æ”¹çš„å­—æ®µ
      const current = await api("/settings");
      
      // åªæ›´æ–°ç”¨æˆ·å¡«å†™çš„å­—æ®µ
      const updates = {
        provider: "openai_compatible",
        base_url: base_url || current.base_url,
        model: model || current.model,
        max_input_tokens,
        max_output_tokens,
        temperature,
        dev_mode
      };
      
      // åªæœ‰ç”¨æˆ·æ–°å¡«å†™äº†API keyæ‰æ›´æ–°ï¼ˆé¿å…ä¿å­˜è™šå‡çš„"********"ï¼‰
      if (api_key) {
        updates.api_key = api_key;
      } else if (current.api_key && current.api_key !== "********") {
        // ä¿ç•™ç°æœ‰çš„çœŸå®API key
        updates.api_key = current.api_key;
      }
      
      // éªŒè¯å¿…è¦å­—æ®µ
      if (!updates.base_url || !updates.model) {
        status.textContent = "Please fill in Base URL and Model";
        return;
      }
      
      if (max_input_tokens < 100 || max_input_tokens > 128000) {
        status.textContent = "Max Input Tokens must be between 100 and 128000";
        return;
      }
      
      if (max_output_tokens < 100 || max_output_tokens > 32000) {
        status.textContent = "Max Output Tokens must be between 100 and 32000";
        return;
      }
      
      if (temperature < 0 || temperature > 2) {
        status.textContent = "Temperature must be between 0 and 2";
        return;
      }
      
      status.textContent = "Saving...";
      await api("/settings", "POST", updates);
      devModeEnabled = dev_mode;
      status.textContent = "Settings saved successfully!";
    } catch (e) {
      status.textContent = "Save failed: " + e.message;
    }
  };


  document.getElementById("health").onclick = async () => {
    const status = document.getElementById("status");
    try {
      status.textContent = "Testing...";
      const result = await api("/health");
      status.textContent = "âœ“ Backend OK";
    } catch (e) {
      status.textContent = "âœ— Backend connection failed: " + e.message;
    }
  };

  // Send message function
  async function sendMessage() {
    const msg = document.getElementById("msg").value.trim();
    if (!msg) return;
    document.getElementById("msg").value = "";
    addBubble(msg, "user");
    meta.textContent = "Waiting for reply...";
    try {
      // è·å–ç”¨æˆ·ä¿¡æ¯
      const userProfile = getUserProfile();
      
      const out = await api("/chat", "POST", { 
        user_message: msg, 
        session_id: "default",
        user_profile: userProfile
      });
      addBubble(out.assistant_message, "assistant", out.token_info);
      
      // æ„å»ºçŠ¶æ€ä¿¡æ¯
      let statusText = `Mode=${out.mode} â€¢ Memory cards=${out.used_memory_cards.length}`;
      
      // å¦‚æœå¼€å¯äº†å¼€å‘è€…æ¨¡å¼ï¼Œæ˜¾ç¤ºtokenä¿¡æ¯
      if (devModeEnabled && out.token_info) {
        const ti = out.token_info;
        statusText += ` â€¢ Tokens: prompt=${ti.prompt_tokens || 0}, completion=${ti.completion_tokens || 0}, total=${ti.total_tokens || 0}`;
        statusText += ` (est. input=${ti.estimated_input_tokens || 0}, system=${ti.system_prompt_tokens || 0})`;
      }
      
      meta.textContent = statusText;
      
      // Auto-save conversation after each chat
      // If no conversation is loaded, create a new one with auto-generated title
      if (!currentLoadedConversation) {
        // Create new conversation with first message as title
        const autoTitle = msg.substring(0, 50) + (msg.length > 50 ? '...' : '');
        currentLoadedConversation = {
          conversation_id: `engine_${Date.now()}`,
          title: autoTitle,
          messages: []
        };
        // Show the header/footer
        loadedConvHeader.style.display = 'block';
        loadedConvFooter.style.display = 'block';
        loadedConvTitleHeader.value = autoTitle;
        loadedConvMetaHeader.textContent = `ID: ${currentLoadedConversation.conversation_id}`;
      }
      
      console.log('[DEBUG] Auto-saving conversation after chat...');
      await saveCurrentConversation();
      
    } catch (e) {
      addBubble("Backend error: " + e.message, "assistant");
      meta.textContent = "Request failed";
    }
  }

  // Send button click
  document.getElementById("send").onclick = sendMessage;

  // Input box keyboard event: Enter to send, Shift+Enter to newline
  document.getElementById("msg").onkeydown = (e) => {
    if (e.key === "Enter") {
      if (e.shiftKey) {
        // Shift+Enter: newline (default behavior)
        return;
      } else {
        // Enter: send
        e.preventDefault();
        sendMessage();
      }
    }
  };

  document.getElementById("clear").onclick = async () => {
    chatlog.innerHTML = "";
    meta.textContent = "Clearing...";
    
    // Hide loaded conversation UI
    loadedConvHeader.style.display = 'none';
    loadedConvFooter.style.display = 'none';
    currentLoadedConversation = null;
    
    try {
      await api("/clear-history", "POST", { session_id: "default" });
      meta.textContent = "Chat history cleared";
    } catch (e) {
      meta.textContent = "Frontend cleared, backend clear failed";
    }
  };

  loadSettings();

  // ==================== System Prompt Modal Window ====================
  const systemPromptModal = document.getElementById('system-prompt-modal');
  const openSystemPromptBtn = document.getElementById('open-system-prompt-window');
  const closeSystemPromptBtn = document.getElementById('close-system-prompt-modal');
  const systemPromptInput = document.getElementById('system-prompt-input');
  const customPromptName = document.getElementById('custom-prompt-name');
  const saveSystemPromptBtn = document.getElementById('save-system-prompt');
  const resetSystemPromptBtn = document.getElementById('reset-system-prompt');
  const systemPromptStatus = document.getElementById('system-prompt-status');
  const systemPromptTemplateSelect = document.getElementById('system-prompt-template-select');
  const templateStatus = document.getElementById('template-status');
  const customPromptSection = document.getElementById('custom-prompt-section');
  
  // å½“å‰é€‰ä¸­çš„æ¨¡æ¿å†…å®¹å’ŒID
  let currentTemplateContent = '';
  let lastSelectedTemplateId = 'warm'; // é»˜è®¤ä¸ºwarm
  
  // åŠ è½½æ¨¡æ¿åˆ—è¡¨
  async function loadTemplatesList() {
    try {
      const data = await api('/settings/system-prompt/templates');
      const templates = data.templates || [];
      
      // Clear existing options (including custom)
      while (systemPromptTemplateSelect.options.length > 0) {
        systemPromptTemplateSelect.remove(0);
      }
      
      // Add template options first
      templates.forEach(template => {
        const option = document.createElement('option');
        option.value = template.id;
        option.textContent = template.title;
        systemPromptTemplateSelect.appendChild(option);
      });
      
      // Add custom option at the end
      const customOption = document.createElement('option');
      customOption.value = 'custom';
      customOption.textContent = 'Custom (Create your own)';
      systemPromptTemplateSelect.appendChild(customOption);
      
      if (templates.length > 0) {
        templateStatus.textContent = `${templates.length} built-in personalities available`;
      }
    } catch (e) {
      templateStatus.textContent = 'Failed to load: ' + e.message;
    }
  }
  
  // è®¡ç®—å¹¶æ˜¾ç¤ºsystem promptçš„tokenæ•°
  function updateSystemPromptTokensInfo(content) {
    const tokensInfo = document.getElementById('system_prompt_tokens_info');
    if (!content) {
      tokensInfo.textContent = '';
      return;
    }
    // è¿‘ä¼¼è®¡ç®—tokenæ•°ï¼ˆ4å­—ç¬¦â‰ˆ1 tokenï¼‰
    const estimatedTokens = Math.ceil(content.length / 4);
    tokensInfo.textContent = `Current system prompt: ~${estimatedTokens} tokens`;
  }
  
  // åŠ è½½æŒ‡å®šæ¨¡æ¿
  async function loadTemplateContent(templateId) {
    try {
      const data = await api(`/settings/system-prompt/templates/${templateId}`);
      
      if (data.status === 'success') {
        currentTemplateContent = data.content;
        systemPromptStatus.textContent = `Using: ${data.title}`;
        
        // æ›´æ–°system prompt tokensæ˜¾ç¤º
        updateSystemPromptTokensInfo(data.content);
        
        // è‡ªåŠ¨ä¿å­˜åˆ°backend
        await api('/settings/system-prompt', 'POST', {
          system_prompt: data.content
        });
        systemPromptStatus.textContent = `âœ“ Switched to: ${data.title}`;
      } else {
        systemPromptStatus.textContent = 'Error: ' + (data.error || 'Unknown error');
      }
    } catch (e) {
      systemPromptStatus.textContent = 'Failed to load: ' + e.message;
    }
  }
  
  // ç›‘å¬æ¨¡æ¿é€‰æ‹©å˜åŒ–
  systemPromptTemplateSelect.onchange = async () => {
    const templateId = systemPromptTemplateSelect.value;
    lastSelectedTemplateId = templateId;
    
    // ä¿å­˜é€‰æ‹©åˆ°æœ¬åœ°å­˜å‚¨
    localStorage.setItem('lastSelectedTemplateId', templateId);
    
    if (templateId === 'custom') {
      customPromptSection.style.display = 'block';
      currentTemplateContent = '';
      customPromptName.value = '';
      systemPromptStatus.textContent = '';
    } else {
      customPromptSection.style.display = 'none';
      await loadTemplateContent(templateId);
    }
  };
  
  // Open system prompt window
  openSystemPromptBtn.onclick = async () => {
    systemPromptModal.classList.add('show');
    await loadTemplatesList();
    await loadSystemPrompt();
  };
  
  // Close system prompt window
  closeSystemPromptBtn.onclick = () => {
    systemPromptModal.classList.remove('show');
  };
  
  // Click modal background to close
  systemPromptModal.onclick = (e) => {
    if (e.target === systemPromptModal) {
      systemPromptModal.classList.remove('show');
    }
  };
  
  // Load system prompt from settings
  async function loadSystemPrompt() {
    try {
      const data = await api('/settings/system-prompt');
      const savedPrompt = data.system_prompt || '';
      
      // ä»æœ¬åœ°å­˜å‚¨æ¢å¤ä¸Šæ¬¡é€‰æ‹©çš„æ¨¡æ¿ID
      const savedTemplateId = localStorage.getItem('lastSelectedTemplateId') || 'warm';
      lastSelectedTemplateId = savedTemplateId;
      
      if (savedPrompt) {
        systemPromptInput.value = savedPrompt;
      } else {
        systemPromptInput.value = '';
      }
      
      // è®¾ç½®ä¸‹æ‹‰æ¡†ä¸ºä¸Šæ¬¡é€‰æ‹©çš„å€¼
      systemPromptTemplateSelect.value = savedTemplateId;
      
      // è§¦å‘changeäº‹ä»¶æ¥æ›´æ–°UI
      if (savedTemplateId === 'custom') {
        customPromptSection.style.display = 'block';
        systemPromptStatus.textContent = '';
      } else {
        customPromptSection.style.display = 'none';
        await loadTemplateContent(savedTemplateId);
      }
    } catch (e) {
      systemPromptStatus.textContent = 'Failed to load: ' + e.message;
    }
  }
  
  // Save system prompt
  saveSystemPromptBtn.onclick = async () => {
    try {
      const contentToSave = systemPromptInput.value.trim();
      
      if (!contentToSave) {
        systemPromptStatus.textContent = 'Cannot save empty prompt';
        return;
      }
      
      systemPromptStatus.textContent = 'Saving...';
      
      // ä¿å­˜è‡ªå®šä¹‰äººæ ¼
      const saveResponse = await api('/settings/system-prompt/save-custom', 'POST', {
        title: customPromptName.value.trim() || 'My Custom Personality',
        content: contentToSave
      });
      
      if (saveResponse.status === 'success') {
        const personalityId = saveResponse.personality_id;
        const personalityTitle = saveResponse.title;
        
        // ä¿å­˜åˆ°settings
        await api('/settings/system-prompt', 'POST', {
          system_prompt: contentToSave
        });
        
        // é‡æ–°åŠ è½½æ¨¡æ¿åˆ—è¡¨
        await loadTemplatesList();
        
        // é€‰ä¸­æ–°ä¿å­˜çš„äººæ ¼
        systemPromptTemplateSelect.value = personalityId;
        lastSelectedTemplateId = personalityId;
        localStorage.setItem('lastSelectedTemplateId', personalityId);
        
        // éšè—è‡ªå®šä¹‰è¾“å…¥æ¡†
        customPromptSection.style.display = 'none';
        
        systemPromptStatus.textContent = `âœ“ Saved: ${personalityTitle}`;
      } else {
        systemPromptStatus.textContent = 'Error: ' + (saveResponse.error || 'Unknown error');
      }
    } catch (e) {
      systemPromptStatus.textContent = 'Failed to save: ' + e.message;
    }
  };
  
  // Reset system prompt
  resetSystemPromptBtn.onclick = () => {
    if (confirm('Clear custom personality?')) {
      systemPromptInput.value = '';
      customPromptName.value = '';
      systemPromptStatus.textContent = 'Cleared (not saved yet)';
    }
  };

  // ==================== Conversations Modal Window ====================
  const conversationsModal = document.getElementById('conversations-modal');
  const openConversationsBtn = document.getElementById('open-conversations-window');
  const closeConversationsBtn = document.getElementById('close-conversations-modal');
  const conversationSearch = document.getElementById('conversation-search');
  const reloadConversationsBtn = document.getElementById('reload-conversations-btn');
  
  // New UI elements in chat window
  const loadedConvHeader = document.getElementById('loaded-conv-header');
  const loadedConvFooter = document.getElementById('loaded-conv-footer');
  const loadedConvTitleHeader = document.getElementById('loaded-conv-title-header');
  const loadedConvMetaHeader = document.getElementById('loaded-conv-meta-header');
  const loadedConvMetaFooter = document.getElementById('loaded-conv-meta-footer');
  
  let conversationsList = [];
  let selectedConversationId = null;
  let currentLoadedConversation = null;  // Track currently loaded conversation
  
  // Open conversations window
  openConversationsBtn.onclick = () => {
    conversationsModal.classList.add('show');
    loadConversationsList();
  };
  
  // Close conversations window
  closeConversationsBtn.onclick = () => {
    conversationsModal.classList.remove('show');
  };
  
  // Click modal background to close
  conversationsModal.onclick = (e) => {
    if (e.target === conversationsModal) {
      conversationsModal.classList.remove('show');
    }
  };
  
  // Reload conversations from conversations.json
  reloadConversationsBtn.onclick = async () => {
    const statusEl = document.getElementById('conversation-status');
    
    // Show custom confirm dialog
    const confirmed = await showConfirm('é‡æ–°åŠ è½½åˆå§‹èŠå¤©è®°å½•ï¼Ÿ');
    
    if (!confirmed) {
      return;
    }
    
    try {
      reloadConversationsBtn.disabled = true;
      reloadConversationsBtn.textContent = 'â³ Reloading...';
      statusEl.textContent = 'Reloading conversations from original file...';
      
      const result = await api('/engine-conversations/reload', { method: 'POST' });
      
      if (result.ok) {
        statusEl.textContent = 'âœ“ Conversations reloaded successfully';
        await loadConversationsList();
      } else {
        statusEl.textContent = 'Error: ' + (result.error || 'Failed to reload');
      }
    } catch (e) {
      statusEl.textContent = 'Failed to reload: ' + e.message;
    } finally {
      reloadConversationsBtn.disabled = false;
      reloadConversationsBtn.textContent = 'ğŸ”„ Reload';
    }
  };
  
  // Update title in both header and footer when user types
  loadedConvTitleHeader.oninput = () => {
    if (currentLoadedConversation) {
      currentLoadedConversation.title = loadedConvTitleHeader.value;
    }
  };
  
  // Helper function to save current conversation to file
  async function saveCurrentConversation() {
    const messages = [];
    let messageIndex = 0;
    chatlog.querySelectorAll('.bubble').forEach(bubble => {
      // Note: addBubble uses 'u' for user, 'a' for assistant
      const role = bubble.classList.contains('u') ? 'user' : 'assistant';
      
      // Extract only the message content, excluding token info div
      let content = bubble.textContent;
      
      // If this is an assistant message and there's a muted token div child, remove its text
      if (role === 'assistant') {
        const tokenDiv = bubble.querySelector('.muted');
        if (tokenDiv) {
          // Get text excluding the token div
          const textNodes = [];
          for (let child of bubble.childNodes) {
            if (child.nodeType === Node.TEXT_NODE) {
              textNodes.push(child.textContent);
            }
          }
          content = textNodes.join('').trim() || content.replace(tokenDiv.textContent, '').trim();
        }
      }
      
      messages.push({ 
        id: `msg_${messageIndex++}`,
        role, 
        content 
      });
    });
    
    if (messages.length === 0) {
      console.log('[DEBUG] No messages to save');
      return;
    }
    
    console.log('[DEBUG] Messages to save:', JSON.stringify(messages, null, 2));
    
    const title = loadedConvTitleHeader.value.trim() || `Conversation ${new Date().toLocaleString()}`;
    const conversationId = currentLoadedConversation?.conversation_id || `engine_${Date.now()}`;
    
    try {
      console.log('[DEBUG] Auto-saving conversation:', conversationId);
      
      const result = await api('/engine-conversations/save', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          conversation_id: conversationId,
          title: title,
          messages: messages
        })
      });
      
      if (result.ok) {
        currentLoadedConversation = {
          conversation_id: result.conversation_id,
          title: result.title,
          messages: messages
        };
        loadedConvTitleHeader.value = result.title;
        loadedConvMetaHeader.textContent = `ID: ${result.conversation_id}`;
        loadedConvMetaFooter.textContent = `ğŸ“ ${messages.length} messages | âœ“ Saved`;
        
        // Refresh the list
        await loadConversationsList();
        
        console.log('[DEBUG] Conversation auto-saved successfully');
      } else {
        console.error('[DEBUG] Failed to save:', result.error);
      }
    } catch (e) {
      console.error('[DEBUG] Failed to save:', e.message);
    }
  };
  
  // Search conversations
  let searchTimeout = null;
  conversationSearch.oninput = () => {
    clearTimeout(searchTimeout);
    searchTimeout = setTimeout(() => {
      loadConversationsList(conversationSearch.value.trim());
    }, 300);
  };
  
  // Load conversations list
  async function loadConversationsList(query = '') {
    const listEl = document.getElementById('conversation-list');
    const statusEl = document.getElementById('conversation-status');
    
    try {
      listEl.innerHTML = '<div class="muted" style="text-align:center; padding:30px;">Loading...</div>';
      
      // Use engine-conversations endpoint (read-write file)
      const url = query ? `/engine-conversations?query=${encodeURIComponent(query)}` : '/engine-conversations';
      const data = await api(url);
      conversationsList = data.conversations || [];
      
      if (conversationsList.length === 0) {
        listEl.innerHTML = '<div class="muted" style="text-align:center; padding:30px;">No conversations found</div>';
        statusEl.textContent = '';
        return;
      }
      
      listEl.innerHTML = conversationsList.map(conv => `
        <div class="conversation-item" data-id="${conv.conversation_id}">
          <div class="conversation-item-content">
            <div class="conversation-title">${escapeHtml(conv.title)}</div>
            <div class="conversation-meta">
              <span>Messages: ${conv.message_count}</span>
              <span>${conv.update_time ? formatDate(conv.update_time) : 'Unknown date'}</span>
            </div>
          </div>
          <div class="conversation-item-actions">
            <button class="delete-btn" onclick="event.stopPropagation(); deleteConversation('${conv.conversation_id}')">Delete</button>
          </div>
        </div>
      `).join('');
      
      statusEl.textContent = `Found ${conversationsList.length} conversations`;
      
      // Add click handlers
      listEl.querySelectorAll('.conversation-item').forEach(item => {
        item.onclick = () => selectConversation(item.dataset.id);
      });
      
    } catch (e) {
      listEl.innerHTML = `<div class="muted" style="text-align:center; padding:30px;">Failed to load: ${e.message}</div>`;
      statusEl.textContent = 'Error loading conversations';
    }
  }
  
  // Format timestamp to readable date
  function formatDate(timestamp) {
    const date = new Date(timestamp * 1000);
    return date.toLocaleDateString('en-US', { 
      year: 'numeric', 
      month: 'short', 
      day: 'numeric',
      hour: '2-digit',
      minute: '2-digit'
    });
  }
  
  // Select and load a conversation
  async function deleteConversation(conversationId) {
    if (!confirm('Are you sure you want to delete this conversation? This action cannot be undone.')) {
      return;
    }
    
    try {
      const statusEl = document.getElementById('conversation-status');
      statusEl.textContent = 'Deleting...';
      
      // For now, we can only delete using the available API
      // This is a client-side delete simulation - you may need to implement a backend delete endpoint
      const data = await api(`/engine-conversations/delete/${conversationId}`, {
        method: 'POST'
      });
      
      if (data.error) {
        statusEl.textContent = `Error: ${data.error}`;
        return;
      }
      
      // Reload conversations list
      loadConversationsList();
      statusEl.textContent = 'Conversation deleted';
      
      // If this was the selected conversation, clear preview
      if (selectedConversationId === conversationId) {
        const previewEl = document.getElementById('conversation-list').querySelector('.conversation-preview');
        if (previewEl) {
          previewEl.remove();
        }
        selectedConversationId = null;
      }
      
    } catch (e) {
      document.getElementById('conversation-status').textContent = `Delete failed: ${e.message}`;
    }
  }

  async function selectConversation(conversationId) {
    const statusEl = document.getElementById('conversation-status');
    const listEl = document.getElementById('conversation-list');
    
    // Highlight selected item
    listEl.querySelectorAll('.conversation-item').forEach(item => {
      item.style.borderColor = item.dataset.id === conversationId 
        ? 'rgba(80,120,255,.6)' 
        : 'rgba(255,255,255,.08)';
    });
    
    try {
      statusEl.textContent = 'Loading conversation...';
      
      // Use engine-conversations endpoint (read-write file)
      const data = await api(`/engine-conversations/${conversationId}`);
      
      if (data.error) {
        statusEl.textContent = data.error;
        return;
      }
      
      selectedConversationId = conversationId;
      
      // Show preview of messages
      const selectedItem = listEl.querySelector(`[data-id="${conversationId}"]`);
      
      // Remove existing preview
      const existingPreview = listEl.querySelector('.conversation-preview');
      if (existingPreview) {
        existingPreview.remove();
      }
      
      // Add preview below selected item
      const previewHtml = `
        <div class="conversation-preview">
          <div style="margin-bottom:10px; display:flex; justify-content:space-between; align-items:center;">
            <span class="muted">${data.messages.length} messages</span>
            <button id="load-to-chat" style="padding:6px 12px; font-size:12px; background:rgba(80,120,255,.3); border-color:rgba(80,120,255,.5);">Load to Chat</button>
          </div>
          ${data.messages.slice(0, 10).map(msg => `
            <div class="preview-message ${msg.role}">
              <div class="role">${msg.role}</div>
              <div>${escapeHtml(msg.content.substring(0, 300))}${msg.content.length > 300 ? '...' : ''}</div>
            </div>
          `).join('')}
          ${data.messages.length > 10 ? `<div class="muted" style="text-align:center; padding:10px;">... and ${data.messages.length - 10} more messages</div>` : ''}
        </div>
      `;
      
      selectedItem.insertAdjacentHTML('afterend', previewHtml);
      
      // Add load to chat handler
      document.getElementById('load-to-chat').onclick = () => {
        loadConversationToChat(data);
      };
      
      statusEl.textContent = `Loaded: ${data.title}`;
      
    } catch (e) {
      statusEl.textContent = `Failed to load: ${e.message}`;
    }
  }
  
  // Load conversation to main chat
  async function loadConversationToChat(conversationData) {
    const statusEl = document.getElementById('conversation-status');
    
    try {
      statusEl.textContent = 'Loading to chat context...';
      console.log('[DEBUG] Loading conversation to context:', conversationData.conversation_id);
      
      // Load to agent's context first
      const result = await api('/load-conversation-to-context', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          conversation_id: conversationData.conversation_id,
          session_id: 'default'
        })
      });
      
      console.log('[DEBUG] API response:', result);
      
      if (!result.ok) {
        statusEl.textContent = 'Warning: Failed to load to agent context: ' + (result.error || 'Unknown error');
        console.error('[DEBUG] Failed to load context:', result.error);
      } else {
        statusEl.textContent = `âœ“ Loaded ${result.message_count} messages to context`;
      }
      
      // Clear current chat
      chatlog.innerHTML = '';
      
      // Add messages to chat display
      conversationData.messages.forEach(msg => {
        if (msg.role === 'user' || msg.role === 'assistant') {
          addBubble(msg.content, msg.role === 'user' ? 'user' : 'assistant');
        }
      });
      
      // Update current loaded conversation tracker
      currentLoadedConversation = conversationData;
      
      // Show loaded conversation header and footer
      loadedConvHeader.style.display = 'block';
      loadedConvFooter.style.display = 'block';
      loadedConvTitleHeader.value = conversationData.title;
      loadedConvMetaHeader.textContent = `ID: ${conversationData.conversation_id}`;
      loadedConvMetaFooter.textContent = `ğŸ“ ${conversationData.messages.length} messages`;
      
      // Close modal
      conversationsModal.classList.remove('show');
      
      // Update meta
      meta.textContent = `Loaded: ${conversationData.title} (${conversationData.messages.length} messages) - Context synced`;
      
    } catch (e) {
      console.error('[DEBUG] Exception:', e);
      statusEl.textContent = 'Failed to load: ' + e.message;
      // Still show the messages even if context sync failed
      chatlog.innerHTML = '';
      conversationData.messages.forEach(msg => {
        if (msg.role === 'user' || msg.role === 'assistant') {
          addBubble(msg.content, msg.role === 'user' ? 'user' : 'assistant');
        }
      });
      conversationsModal.classList.remove('show');
      meta.textContent = `Loaded: ${conversationData.title} (display only - context sync failed)`;
    }
  }

  // ==================== Memory Modal Window ====================
  // Open/close handlers for memory modal window
  const memoryModal = document.getElementById('memory-modal');
  const openMemoryBtn = document.getElementById('open-memory-window');
  const closeMemoryBtn = document.getElementById('close-memory-modal');
  
  // Open memory window
  openMemoryBtn.onclick = () => {
    memoryModal.classList.add('show');
    loadPlugins();
    loadMemory();
  };
  
  // Close memory window
  closeMemoryBtn.onclick = () => {
    memoryModal.classList.remove('show');
  };
  
  // Click modal background to close
  memoryModal.onclick = (e) => {
    if (e.target === memoryModal) {
      memoryModal.classList.remove('show');
    }
  };
  
  // ESC key to close modals
  document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape') {
      if (memoryModal.classList.contains('show')) {
        memoryModal.classList.remove('show');
      }
      if (conversationsModal.classList.contains('show')) {
        conversationsModal.classList.remove('show');
      }
      if (systemPromptModal.classList.contains('show')) {
        systemPromptModal.classList.remove('show');
      }
    }
  });

  // ==================== Memory Plugin System ====================
  
  let currentPluginId = null;
  let availablePlugins = [];
  
  // Tab switching functionality
  document.querySelectorAll('.tab-btn').forEach(btn => {
    btn.onclick = () => {
      document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
      document.querySelectorAll('.tab-content').forEach(c => c.style.display = 'none');
      btn.classList.add('active');
      document.getElementById(btn.dataset.tab + '-tab').style.display = 'block';
    };
  });

  // Load and display memories (two-list system)
  async function loadMemory() {
    const coreMemoryList = document.getElementById('core-memory-list');
    const memoryLibraryList = document.getElementById('memory-library-list');
    const entityList = document.getElementById('entity-list');
    const relationList = document.getElementById('relation-list');
    const memoryStats = document.getElementById('memory-stats');
    
    try {
      // Use visualization API
      const data = await api("/memory/visualization");
      
      // Display memory list (split into core and library based on importance)
      const memories = data.recent_memories || (data.memory_tree?.recent_memories) || [];
      
      // Core memory: importance >= 0.8 (memories marked as important)
      // Library: importance < 0.8
      const CORE_THRESHOLD = 0.8;
      
      const coreMemories = memories.filter(m => 
        ((m.effective_importance || m.importance) || 0) >= CORE_THRESHOLD
      );
      
      const libraryMemories = memories.filter(m => 
        ((m.effective_importance || m.importance) || 0) < CORE_THRESHOLD
      );
      
      // Display core memories
      if (coreMemories.length > 0) {
        coreMemoryList.innerHTML = coreMemories.map(m => `
          <div class="memory-item core-item" data-id="${m.id || m.content.substring(0,30)}" data-content="${escapeHtml(m.content)}">
            <div class="memory-content">${escapeHtml(m.content)}</div>
            <div class="memory-meta">
              <span>${new Date(m.timestamp).toLocaleDateString()}</span>
              <span style="color:#80d8ff; font-weight:600;">${((m.effective_importance || m.importance) * 100).toFixed(0)}%</span>
            </div>
          </div>
        `).join('');
        
        // Add context menu to core items
        coreMemoryList.querySelectorAll('.core-item').forEach(item => {
          item.oncontextmenu = (e) => showCoreMemoryContextMenu(e, item);
        });
      } else {
        coreMemoryList.innerHTML = '<div class="muted" style="text-align:center; padding:20px; font-size:12px;">No core memories yet</div>';
      }
      
      // Display memory library
      if (libraryMemories.length > 0) {
        memoryLibraryList.innerHTML = libraryMemories.map(m => `
          <div class="memory-item library-item" data-id="${m.id || m.content.substring(0,30)}" data-content="${escapeHtml(m.content)}">
            <div class="memory-content">${escapeHtml(m.content)}</div>
            <div class="memory-meta">
              <span>${new Date(m.timestamp).toLocaleDateString()}</span>
              <span style="opacity:0.6; font-size:11px;">${((m.effective_importance || m.importance) * 100).toFixed(0)}%</span>
            </div>
          </div>
        `).join('');
        
        // Add context menu to library items
        memoryLibraryList.querySelectorAll('.library-item').forEach(item => {
          item.oncontextmenu = (e) => showLibraryMemoryContextMenu(e, item);
        });
      } else {
        memoryLibraryList.innerHTML = '<div class="muted" style="text-align:center; padding:20px; font-size:12px;">Click refresh to load memories or add new ones below...</div>';
      }
      
      // Display entities (if plugin supports)
      const entities = data.knowledge_graph?.entities || [];
      const plugin = availablePlugins.find(p => p.id === currentPluginId);
      
      if (plugin?.supports_graph && entities.length > 0) {
        entityList.innerHTML = entities.map(e => `
          <div class="entity-item">
            <div class="entity-name">${escapeHtml(e.name)}</div>
            <div class="entity-type">${e.type} â€¢ Importance: ${(e.importance * 100).toFixed(0)}%</div>
          </div>
        `).join('');
      } else if (!plugin?.supports_graph) {
        entityList.innerHTML = '<div class="muted" style="text-align:center; padding:10px;">Current plugin does not support knowledge graph</div>';
      } else {
        entityList.innerHTML = '<div class="muted" style="text-align:center; padding:10px;">No entities found</div>';
      }
      
      // Display relationships
      const relationships = data.knowledge_graph?.relationships || [];
      if (relationships.length > 0) {
        relationList.innerHTML = relationships.map(r => `
          <div class="relation-item">
            <strong>${escapeHtml(r.source)}</strong> â†’ <span style="opacity:0.7">${r.type}</span> â†’ <strong>${escapeHtml(r.target)}</strong>
          </div>
        `).join('');
      } else {
        relationList.innerHTML = '<div class="muted" style="text-align:center; padding:10px;">No relationships</div>';
      }
      
      // Statistics info
      const stats = data.stats || {};
      const activePlugin = data.active_plugin || currentPluginId;
      const pluginName = availablePlugins.find(p => p.id === activePlugin)?.name || activePlugin;
      
      memoryStats.innerHTML = `
        <div class="stat-row"><span>Vector Memory Plugin</span><strong>Active</strong></div>
        <div class="stat-row"><span>Total Memories</span><strong>${stats.total_memories || memories.length}</strong></div>
        ${stats.total_entities ? `<div class="stat-row"><span>Entities</span><strong>${stats.total_entities}</strong></div>` : ''}
        ${stats.total_relationships ? `<div class="stat-row"><span>Relationships</span><strong>${stats.total_relationships}</strong></div>` : ''}
        <div style="margin-top:8px; font-size:10px; opacity:0.5;">
          Right-click library memories to move to core
        </div>
      `;
      
    } catch (e) {
      coreMemoryList.innerHTML = `<div class="muted" style="text-align:center; padding:20px; font-size:12px;">Error: ${e.message}</div>`;
    }
  }
  
  // Core memory keywords for auto-detection (stricter matching with context awareness)
  const CORE_KEYWORDS = [
    // ç§°å‘¼ç›¸å…³
    'åå­—', 'å«åš', 'ç§°å‘¼', 'æ˜µç§°', 'æˆ‘æ˜¯', 'æˆ‘å«', 
    'my name', 'call me', 'i am', 'i\'m', 'my name is',
    // èŒä¸šç›¸å…³
    'èŒä¸š', 'å·¥ä½œ', 'èŒä½', 'æˆ‘çš„å·¥ä½œ', 'ä»»èŒ', 
    'job', 'work as', 'career', 'profession', 'employed',
    // å®¶åº­å…³ç³»
    'å¦»å­', 'ä¸ˆå¤«', 'å­©å­', 'å„¿å­', 'å¥³å„¿', 'çˆ¶äº²', 'æ¯äº²', 'çˆ¸çˆ¸', 'å¦ˆå¦ˆ', 'å®¶äºº',
    'wife', 'husband', 'son', 'daughter', 'father', 'mother', 'parent', 'family',
    // æ ¸å¿ƒä¸ªäººä¿¡æ¯
    'å¹´é¾„', 'ç”Ÿæ—¥', 'å‡ºç”Ÿ', 
    'age', 'born', 'birthday', 'years old',
    // åŸå¸‚/åœ°ç‚¹ï¼ˆä¸¥æ ¼åŒ¹é…ï¼Œé¿å…"from game"è¯¯åŒ¹é…ï¼‰
    'ä½åœ¨', 'ç”Ÿæ´»åœ¨', 'æ¥è‡ªäº', 
    'live in', 'live at', 'from', 'located in', 'living in', 'hometown', 'city:'
  ];
  
  // Exclusion patterns to avoid false positives
  const EXCLUSION_PATTERNS = [
    /from the game/i,
    /from a game/i,
    /from.*game/i,
    /from.*book/i,
    /from.*movie/i,
    /from.*show/i,
    /from.*series/i
  ];
  
  // Check if memory content matches core keywords (with stricter word boundary logic)
  function matchesCoreKeywords(content) {
    const lowerContent = content.toLowerCase();
    
    // First check exclusion patterns (false positive prevention)
    for (let pattern of EXCLUSION_PATTERNS) {
      if (pattern.test(lowerContent)) {
        return false;  // Exclude this memory from core
      }
    }
    
    // ä½¿ç”¨å•è¯è¾¹ç•ŒåŒ¹é…ï¼Œé¿å…éƒ¨åˆ†å•è¯è¯¯åŒ¹é…
    let matches = 0;
    CORE_KEYWORDS.forEach(keyword => {
      // åˆ›å»ºæ­£åˆ™è¡¨è¾¾å¼ï¼Œä½¿ç”¨å•è¯è¾¹ç•Œ(\b)
      const lowerKeyword = keyword.toLowerCase();
      
      // å¯¹äºè‹±æ–‡å…³é”®è¯ä½¿ç”¨å•è¯è¾¹ç•Œæ­£åˆ™
      if (/^[a-z\s':\-]+$/.test(lowerKeyword)) {
        // è‹±æ–‡ï¼šä½¿ç”¨å•è¯è¾¹ç•Œ
        const regex = new RegExp(`\\b${lowerKeyword.replace(/\s+/g, '\\s+')}\\b`, 'g');
        if (regex.test(lowerContent)) {
          matches++;
        }
      } else {
        // ä¸­æ–‡ï¼šä½¿ç”¨includesï¼ˆå› ä¸º\bå¯¹ä¸­æ–‡æ•ˆæœä¸å¥½ï¼‰
        if (lowerContent.includes(lowerKeyword)) {
          matches++;
        }
      }
    });
    
    return matches > 0;
  }
  
  // Context menu for CORE memory items (delete + move to library)
  function showCoreMemoryContextMenu(e, item) {
    e.preventDefault();
    
    // Remove existing context menu
    const existing = document.querySelector('.memory-context-menu');
    if (existing) existing.remove();
    
    const menu = document.createElement('div');
    menu.className = 'memory-context-menu';
    menu.style.cssText = `
      position: fixed;
      top: ${e.clientY}px;
      left: ${e.clientX}px;
      background: rgba(0,0,0,.85);
      border: 1px solid rgba(128,216,255,.3);
      border-radius: 6px;
      padding: 4px;
      z-index: 10000;
      box-shadow: 0 4px 12px rgba(0,0,0,.5);
    `;
    
    // Move to Library option
    const moveOption = document.createElement('div');
    moveOption.style.cssText = `
      padding: 8px 12px;
      font-size: 12px;
      color: #b3e5fc;
      cursor: pointer;
      border-radius: 4px;
      user-select: none;
    `;
    moveOption.textContent = 'ğŸ“š Move to Library';
    moveOption.onmouseover = () => moveOption.style.background = 'rgba(128,216,255,.15)';
    moveOption.onmouseout = () => moveOption.style.background = 'transparent';
    moveOption.onclick = () => {
      const libraryList = document.getElementById('memory-library-list');
      const clone = item.cloneNode(true);
      clone.classList.add('library-item');
      clone.oncontextmenu = (e) => showLibraryMemoryContextMenu(e, clone);
      
      // Remove muted placeholder if exists
      const placeholder = libraryList.querySelector('.muted');
      if (placeholder) placeholder.remove();
      
      libraryList.insertBefore(clone, libraryList.firstChild);
      item.remove();
      
      // Check if core list is empty
      const coreList = document.getElementById('core-memory-list');
      if (!coreList.querySelector('.memory-item')) {
        coreList.innerHTML = '<div class="muted" style="text-align:center; padding:20px; font-size:12px;">No core memories yet</div>';
      }
      
      console.log('[DEBUG] Moved memory to library:', item.dataset.content);
      menu.remove();
    };
    
    // Delete option
    const deleteOption = document.createElement('div');
    deleteOption.style.cssText = `
      padding: 8px 12px;
      font-size: 12px;
      color: #ff8080;
      cursor: pointer;
      border-radius: 4px;
      user-select: none;
    `;
    deleteOption.textContent = 'ğŸ—‘ï¸ Delete';
    deleteOption.onmouseover = () => deleteOption.style.background = 'rgba(255,80,80,.15)';
    deleteOption.onmouseout = () => deleteOption.style.background = 'transparent';
    deleteOption.onclick = async () => {
      if (!confirm('Delete this memory?')) {
        menu.remove();
        return;
      }
      
      const memoryId = item.dataset.id;
      try {
        await api('/memory/delete', 'POST', { memory_id: memoryId });
        console.log('[DEBUG] Deleted memory:', memoryId);
      } catch (err) {
        console.error('Failed to delete from backend:', err);
      }
      
      item.remove();
      
      // Check if core list is empty
      const coreList = document.getElementById('core-memory-list');
      if (!coreList.querySelector('.memory-item')) {
        coreList.innerHTML = '<div class="muted" style="text-align:center; padding:20px; font-size:12px;">No core memories yet</div>';
      }
      
      menu.remove();
    };
    
    menu.appendChild(moveOption);
    menu.appendChild(deleteOption);
    document.body.appendChild(menu);
    
    // Close menu on click elsewhere
    setTimeout(() => {
      document.addEventListener('click', (e) => {
        if (!e.target.closest('.memory-context-menu')) {
          menu.remove();
        }
      }, { once: true });
    }, 0);
  }
  
  // Context menu for LIBRARY memory items (move to core + delete)
  function showLibraryMemoryContextMenu(e, item) {
    e.preventDefault();
    
    // Remove existing context menu
    const existing = document.querySelector('.memory-context-menu');
    if (existing) existing.remove();
    
    const menu = document.createElement('div');
    menu.className = 'memory-context-menu';
    menu.style.cssText = `
      position: fixed;
      top: ${e.clientY}px;
      left: ${e.clientX}px;
      background: rgba(0,0,0,.85);
      border: 1px solid rgba(128,216,255,.3);
      border-radius: 6px;
      padding: 4px;
      z-index: 10000;
      box-shadow: 0 4px 12px rgba(0,0,0,.5);
    `;
    
    // Move to Core option
    const moveOption = document.createElement('div');
    moveOption.style.cssText = `
      padding: 8px 12px;
      font-size: 12px;
      color: #80d8ff;
      cursor: pointer;
      border-radius: 4px;
      user-select: none;
    `;
    moveOption.textContent = 'â­ Move to Core Memory';
    moveOption.onmouseover = () => moveOption.style.background = 'rgba(128,216,255,.15)';
    moveOption.onmouseout = () => moveOption.style.background = 'transparent';
    moveOption.onclick = () => {
      const coreList = document.getElementById('core-memory-list');
      const clone = item.cloneNode(true);
      clone.classList.remove('library-item');
      clone.classList.add('core-item');
      clone.oncontextmenu = (e) => showCoreMemoryContextMenu(e, clone);
      
      // Remove muted placeholder if exists
      const placeholder = coreList.querySelector('.muted');
      if (placeholder) placeholder.remove();
      
      coreList.insertBefore(clone, coreList.firstChild);
      item.remove();
      
      // Check if library list is empty
      const libraryList = document.getElementById('memory-library-list');
      if (!libraryList.querySelector('.memory-item')) {
        libraryList.innerHTML = '<div class="muted" style="text-align:center; padding:20px; font-size:12px;">No memories in library</div>';
      }
      
      console.log('[DEBUG] Moved memory to core:', item.dataset.content);
      menu.remove();
    };
    
    // Delete option
    const deleteOption = document.createElement('div');
    deleteOption.style.cssText = `
      padding: 8px 12px;
      font-size: 12px;
      color: #ff8080;
      cursor: pointer;
      border-radius: 4px;
      user-select: none;
    `;
    deleteOption.textContent = 'ğŸ—‘ï¸ Delete';
    deleteOption.onmouseover = () => deleteOption.style.background = 'rgba(255,80,80,.15)';
    deleteOption.onmouseout = () => deleteOption.style.background = 'transparent';
    deleteOption.onclick = async () => {
      if (!confirm('Delete this memory?')) {
        menu.remove();
        return;
      }
      
      const memoryId = item.dataset.id;
      try {
        await api('/memory/delete', 'POST', { memory_id: memoryId });
        console.log('[DEBUG] Deleted memory:', memoryId);
      } catch (err) {
        console.error('Failed to delete from backend:', err);
      }
      
      item.remove();
      
      // Check if library list is empty
      const libraryList = document.getElementById('memory-library-list');
      if (!libraryList.querySelector('.memory-item')) {
        libraryList.innerHTML = '<div class="muted" style="text-align:center; padding:20px; font-size:12px;">No memories in library</div>';
      }
      
      menu.remove();
    };
    
    menu.appendChild(moveOption);
    menu.appendChild(deleteOption);
    document.body.appendChild(menu);
    
    // Close menu on click elsewhere
    setTimeout(() => {
      document.addEventListener('click', (e) => {
        if (!e.target.closest('.memory-context-menu')) {
          menu.remove();
        }
      }, { once: true });
    }, 0);
  }
  
  // Add new memory handler (with keyword auto-detection for core)
  let addMemoryBtn = document.getElementById('add-memory');
  if (addMemoryBtn) {
    addMemoryBtn.onclick = async () => {
      const textarea = document.getElementById('new-memory');
      const memoryStatus = document.getElementById('memory-status');
      const content = textarea.value.trim();
      
      if (!content) {
        alert('Please enter memory content');
        return;
      }
      
      // Split by newlines for multiple memories
      const memories = content
        .split('\n')
        .map(line => line.trim())
        .filter(line => line.length > 0);
      
      if (memories.length === 0) {
        alert('Please enter memory content');
        return;
      }
      
      try {
        let addedCount = 0;
        let coreCount = 0;
        
        for (const memory of memories) {
          const result = await api('/memory/add', 'POST', {
            content: memory,
            importance: 0.3  // ç¦ç”¨å…³é”®è¯åŒ¹é…ï¼Œå›ºå®šä½¿ç”¨é»˜è®¤é‡è¦æ€§
            // importance: matchesCoreKeywords(memory) ? 0.85 : 0.3  // å·²ç¦ç”¨å…³é”®è¯åŒ¹é…
          });
          addedCount++;
          
          // Check if matches core keywords
          if (matchesCoreKeywords(memory)) {
            coreCount++;
          }
        }
        
        console.log('[DEBUG] Added', addedCount, 'memories,', coreCount, 'matched core keywords');
        
        // Clear textarea
        textarea.value = '';
        
        // Reload memory display
        await loadMemory();
        
        // Show status
        if (coreCount > 0) {
          memoryStatus.textContent = `âœ“ Added ${addedCount} memories (${coreCount} auto-matched to Core)`;
        } else {
          memoryStatus.textContent = `âœ“ Added ${addedCount} memories`;
        }
        
      } catch (e) {
        console.error('Failed to add memory:', e);
        alert('Failed to add memory: ' + e.message);
      }
    };
  }
  
  // Auto-select core memories using LLM (backend API)
  let autoSelectBtn = document.getElementById('auto-select-core');
  if (autoSelectBtn) {
    autoSelectBtn.onclick = async () => {
      const memoryStatus = document.getElementById('memory-status');
      const coreList = document.getElementById('core-memory-list');
      const libraryList = document.getElementById('memory-library-list');
      
      memoryStatus.textContent = 'ğŸ¤– Analyzing memories with AI (strict mode)...';
      autoSelectBtn.disabled = true;
      
      try {
        // Call backend LLM evaluation API
        const result = await api('/memory/evaluate', 'POST', {
          memory_ids: []  // Empty = evaluate all memories
        });
        
        console.log('[DEBUG] LLM evaluation result:', result);
        
        if (result.success) {
          memoryStatus.textContent = result.message;
          
          // ç›´æ¥æ›´æ–° DOMï¼Œä½¿ç”¨åç«¯è¿”å›çš„æ•°æ®
          const coreMemories = result.core_memories || [];
          const libraryMemories = result.library_memories || [];
          
          // æ¸…ç©ºå¹¶é‡æ–°å¡«å……æ ¸å¿ƒè®°å¿†åˆ—è¡¨
          coreList.innerHTML = '';
          if (coreMemories.length === 0) {
            coreList.innerHTML = '<div class="muted" style="text-align:center; padding:20px; font-size:12px;">No core memories</div>';
          } else {
            coreMemories.forEach(mem => {
              const item = document.createElement('div');
              item.className = 'core-item memory-item';
              item.dataset.id = mem.id;
              item.dataset.content = mem.content;
              item.textContent = mem.content;
              item.oncontextmenu = (e) => showCoreMemoryContextMenu(e, item);
              coreList.appendChild(item);
            });
          }
          
          // æ¸…ç©ºå¹¶é‡æ–°å¡«å……åº“è®°å¿†åˆ—è¡¨
          libraryList.innerHTML = '';
          if (libraryMemories.length === 0) {
            libraryList.innerHTML = '<div class="muted" style="text-align:center; padding:20px; font-size:12px;">No memories in library</div>';
          } else {
            libraryMemories.forEach(mem => {
              const item = document.createElement('div');
              item.className = 'library-item memory-item';
              item.dataset.id = mem.id;
              item.dataset.content = mem.content;
              item.textContent = mem.content;
              item.oncontextmenu = (e) => showLibraryMemoryContextMenu(e, item);
              libraryList.appendChild(item);
            });
          }
          
        } else {
          memoryStatus.textContent = 'âŒ ' + (result.message || 'Evaluation failed');
        }
        
      } catch (e) {
        console.error('Failed to auto-select:', e);
        memoryStatus.textContent = 'Auto-select failed: ' + e.message;
      } finally {
        autoSelectBtn.disabled = false;
      }
    };
  }

  function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  }

  document.getElementById('refresh-memory').onclick = () => {
    loadMemory();
  };

  // User Profile Save Handler
  document.getElementById('save-profile').onclick = () => {
    const name = document.getElementById('user_name').value.trim();
    const age = document.getElementById('user_age').value.trim();
    const gender = document.getElementById('user_gender').value;
    const occupation = document.getElementById('user_occupation').value.trim();
    const location = document.getElementById('user_location').value.trim();
    const bio = document.getElementById('user_bio').value.trim();
    
    // ä¿å­˜åˆ° localStorage
    const profileData = {
      name,
      age: age ? parseInt(age) : null,
      gender,
      occupation,
      location,
      bio,
      savedAt: new Date().toISOString()
    };
    
    localStorage.setItem('userProfile', JSON.stringify(profileData));
    
    // æ˜¾ç¤ºä¿å­˜æˆåŠŸæç¤º
    const btn = document.getElementById('save-profile');
    const originalText = btn.textContent;
    btn.textContent = 'âœ“ Saved!';
    btn.style.background = 'rgba(100,200,100,.3)';
    btn.style.borderColor = 'rgba(100,200,100,.4)';
    
    setTimeout(() => {
      btn.textContent = originalText;
      btn.style.background = 'rgba(80,120,255,.3)';
      btn.style.borderColor = 'rgba(80,120,255,.4)';
    }, 2000);
  };
  
  // Load user profile on page init
  function loadUserProfile() {
    const profileData = localStorage.getItem('userProfile');
    if (profileData) {
      try {
        const profile = JSON.parse(profileData);
        document.getElementById('user_name').value = profile.name || '';
        document.getElementById('user_age').value = profile.age || '';
        document.getElementById('user_gender').value = profile.gender || '';
        document.getElementById('user_occupation').value = profile.occupation || '';
        document.getElementById('user_location').value = profile.location || '';
        document.getElementById('user_bio').value = profile.bio || '';
      } catch (e) {
        console.error('Failed to load user profile:', e);
      }
    }
  }
  
  // Get user profile for chat API
  function getUserProfile() {
    const profileData = localStorage.getItem('userProfile');
    if (profileData) {
      try {
        const profile = JSON.parse(profileData);
        // åªè¿”å›æœ‰å€¼çš„å­—æ®µ
        const result = {};
        if (profile.name) result.name = profile.name;
        if (profile.age) result.age = profile.age;
        if (profile.gender) result.gender = profile.gender;
        if (profile.occupation) result.occupation = profile.occupation;
        if (profile.location) result.location = profile.location;
        if (profile.bio) result.bio = profile.bio;
        return Object.keys(result).length > 0 ? result : null;
      } catch (e) {
        console.error('Failed to get user profile:', e);
        return null;
      }
    }
    return null;
  }
  
  // Load user profile when page loads
  loadUserProfile();

  // Clear all memories handler (if needed)
  let clearBtn = document.getElementById('clear-memory');
  if (clearBtn) {
    clearBtn.onclick = async () => {
      if (!confirm('Clear all memories?')) return;
      
      try {
        await api("/memory/clear", "POST");
        loadMemory();
      } catch (e) {
        console.error('Failed to clear:', e);
      }
    };
  }

  // Initialize on page load
  setTimeout(() => {
    loadMemory();
  }, 500);
</script>
</body>
</html>
