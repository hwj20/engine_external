<!doctype html>
<html lang="zh">
<head>
  <meta charset="UTF-8" />
  <meta http-equiv="Content-Security-Policy"
        content="default-src 'self' http://127.0.0.1:8787;
                 script-src 'self' 'unsafe-inline';
                 style-src 'self' 'unsafe-inline';
                 img-src 'self' data:;
                 connect-src 'self' http://127.0.0.1:8787;">
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Engine External</title>
  <style>
    body { font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; margin: 0; background: #0b0f17; color: #e7eefc; }
    header { padding: 14px 18px; display:flex; align-items:center; justify-content:space-between; border-bottom: 1px solid rgba(255,255,255,.08); }
    .badge { font-size: 12px; opacity: .75; }
    .wrap { display:grid; grid-template-columns: 380px 1fr; height: calc(100vh - 52px); }
    .panel { border-right: 1px solid rgba(255,255,255,.08); padding: 14px; overflow:auto; }
    .main { padding: 14px; display:flex; flex-direction:column; gap:10px; }
    .card { background: rgba(255,255,255,.06); border: 1px solid rgba(255,255,255,.08); border-radius: 14px; padding: 12px; }
    label { display:block; font-size: 12px; opacity: .85; margin-bottom: 6px; }
    input, textarea { width:100%; box-sizing:border-box; border-radius: 10px; border:1px solid rgba(255,255,255,.14); background: rgba(0,0,0,.25); color:#e7eefc; padding: 10px; outline:none; }
    textarea { min-height: 90px; resize: vertical; }
    button { cursor:pointer; border-radius: 12px; border:1px solid rgba(255,255,255,.14); background: rgba(255,255,255,.08); color:#e7eefc; padding: 10px 12px; }
    button:hover { background: rgba(255,255,255,.12); }
    .chatlog { flex:1; overflow:auto; display:flex; flex-direction:column; gap:10px; }
    .bubble { padding: 10px 12px; border-radius: 14px; border:1px solid rgba(255,255,255,.10); white-space: pre-wrap; position: relative; transition: all 0.2s; }
    .bubble:hover { border-color: rgba(255,255,255,.20); }
    .bubble-actions { display: none; position: absolute; top: 8px; right: 8px; gap: 4px; z-index: 10; }
    .bubble:hover .bubble-actions { display: flex; }
    .bubble-edit-btn, .bubble-save-btn, .bubble-cancel-btn { padding: 4px 8px; font-size: 11px; border-radius: 6px; border: none; cursor: pointer; background: rgba(80,120,255,.3); color: #e7eefc; }
    .bubble-edit-btn:hover { background: rgba(80,120,255,.5); }
    .bubble-save-btn { background: rgba(100,200,100,.3); }
    .bubble-save-btn:hover { background: rgba(100,200,100,.5); }
    .bubble-cancel-btn { background: rgba(255,100,100,.3); }
    .bubble-cancel-btn:hover { background: rgba(255,100,100,.5); }
    .bubble-content { white-space: pre-wrap; word-break: break-word; }
    .bubble-textarea { width: 100%; min-height: 60px; border-radius: 8px; border: 1px solid rgba(80,120,255,.3); background: rgba(0,0,0,.3); color: #e7eefc; padding: 8px; font-family: inherit; font-size: inherit; resize: vertical; outline: none; margin-bottom: 8px; }
    .u { background: rgba(80,120,255,.12); align-self:flex-end; max-width: 76%; }
    .a { background: rgba(255,255,255,.06); align-self:flex-start; max-width: 76%; }
    .muted { opacity:.75; font-size:12px; }
    
    /* Memory Panel Styles */
    .memory-item { background: rgba(255,255,255,.04); border: 1px solid rgba(255,255,255,.06); border-radius: 8px; padding: 6px 8px; margin-bottom: 4px; transition: all 0.2s; }
    .memory-item:hover { background: rgba(255,255,255,.08); border-color: rgba(255,255,255,.12); }
    .memory-content { font-size: 12px; margin-bottom: 3px; line-height: 1.3; }
    .memory-meta { font-size: 10px; opacity: 0.6; display: flex; gap: 6px; flex-wrap: wrap; }
    .memory-tag { background: rgba(80,120,255,.2); padding: 1px 4px; border-radius: 3px; font-size: 9px; }
    .memory-tag.emotion { background: rgba(255,100,100,.2); }
    .memory-tag.topic { background: rgba(100,200,100,.2); }
    .entity-item { background: rgba(255,200,100,.1); border: 1px solid rgba(255,200,100,.2); border-radius: 6px; padding: 5px 6px; margin-bottom: 4px; }
    .entity-name { font-weight: 600; font-size: 12px; }
    .entity-type { font-size: 10px; opacity: 0.6; }
    .relation-item { font-size: 11px; padding: 4px 6px; background: rgba(100,200,255,.1); border-radius: 4px; margin-bottom: 3px; }
    .tab-buttons { display: flex; gap: 6px; margin-bottom: 10px; }
    .tab-btn { flex: 1; text-align: center; padding: 8px; border-radius: 8px; background: rgba(255,255,255,.04); border: 1px solid rgba(255,255,255,.08); cursor: pointer; font-size: 12px; }
    .tab-btn.active { background: rgba(80,120,255,.2); border-color: rgba(80,120,255,.4); }
    .stat-row { display: flex; justify-content: space-between; padding: 6px 0; border-bottom: 1px solid rgba(255,255,255,.06); font-size: 12px; }
    .importance-bar { height: 2px; background: rgba(255,255,255,.1); border-radius: 1px; overflow: hidden; margin-top: 2px; }
    .importance-fill { height: 100%; background: linear-gradient(90deg, #4080ff, #80c0ff); }
    /* Modal window styles */
    .modal { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,.7); z-index: 1000; align-items: center; justify-content: center; }
    .modal.show { display: flex; }
    .modal-content { background: #0b0f17; border: 1px solid rgba(255,255,255,.12); border-radius: 16px; width: 90%; height: 90%; max-width: 900px; display: flex; flex-direction: column; box-shadow: 0 20px 60px rgba(0,0,0,.6); }
    .modal-header { display: flex; justify-content: space-between; align-items: center; padding: 16px 20px; border-bottom: 1px solid rgba(255,255,255,.08); }
    .modal-header h2 { margin: 0; font-size: 18px; font-weight: 700; }
    .modal-close { cursor: pointer; font-size: 24px; opacity: 0.6; }
    .modal-close:hover { opacity: 1; }
    .modal-body { flex: 1; overflow-y: auto; overflow-x: hidden; padding: 16px 20px; }
    /* Custom scrollbar styles (modal only) */
    .modal-body::-webkit-scrollbar { width: 8px; }
    .modal-body::-webkit-scrollbar-track { background: rgba(255,255,255,.04); border-radius: 4px; }
    .modal-body::-webkit-scrollbar-thumb { background: rgba(80,120,255,.4); border-radius: 4px; }
    .modal-body::-webkit-scrollbar-thumb:hover { background: rgba(80,120,255,.6); }
    
    /* Global scrollbar styles for all elements */
    ::-webkit-scrollbar { width: 10px; height: 10px; }
    ::-webkit-scrollbar-track { background: rgba(255,255,255,.02); }
    ::-webkit-scrollbar-thumb {
      background: linear-gradient(180deg, rgba(80,120,255,.4) 0%, rgba(100,150,255,.3) 100%);
      border-radius: 5px;
      border: 2px solid rgba(255,255,255,.01);
    }
    ::-webkit-scrollbar-thumb:hover {
      background: linear-gradient(180deg, rgba(80,120,255,.6) 0%, rgba(100,150,255,.5) 100%);
    }
    ::-webkit-scrollbar-corner { background: rgba(255,255,255,.01); }
    
    /* Scrollbar for panel */
    .panel::-webkit-scrollbar { width: 8px; }
    .panel::-webkit-scrollbar-track { background: rgba(255,255,255,.02); }
    .panel::-webkit-scrollbar-thumb {
      background: linear-gradient(180deg, rgba(80,120,255,.35) 0%, rgba(100,150,255,.25) 100%);
      border-radius: 4px;
    }
    .panel::-webkit-scrollbar-thumb:hover {
      background: linear-gradient(180deg, rgba(80,120,255,.55) 0%, rgba(100,150,255,.45) 100%);
    }
    
    /* Scrollbar for chatlog */
    .chatlog::-webkit-scrollbar { width: 8px; }
    .chatlog::-webkit-scrollbar-track { background: rgba(255,255,255,.02); }
    .chatlog::-webkit-scrollbar-thumb {
      background: linear-gradient(180deg, rgba(80,120,255,.35) 0%, rgba(100,150,255,.25) 100%);
      border-radius: 4px;
    }
    .chatlog::-webkit-scrollbar-thumb:hover {
      background: linear-gradient(180deg, rgba(80,120,255,.55) 0%, rgba(100,150,255,.45) 100%);
    }
    /* Conversation list styles */
    .conversation-item { background: rgba(255,255,255,.04); border: 1px solid rgba(255,255,255,.08); border-radius: 10px; padding: 12px 14px; margin-bottom: 8px; cursor: pointer; transition: all 0.2s; display: flex; justify-content: space-between; align-items: flex-start; }
    .conversation-item:hover { background: rgba(80,120,255,.15); border-color: rgba(80,120,255,.3); }
    .conversation-item-content { flex: 1; min-width: 0; }
    .conversation-item-actions { display: flex; gap: 8px; opacity: 0; transition: opacity 0.2s; margin-left: 8px; }
    .conversation-item:hover .conversation-item-actions { opacity: 1; }
    .delete-btn { padding: 6px 10px; background: rgba(255,100,100,.15); border: 1px solid rgba(255,100,100,.3); color: #ff6464; border-radius: 6px; font-size: 12px; cursor: pointer; transition: all 0.2s; white-space: nowrap; }
    .delete-btn:hover { background: rgba(255,100,100,.25); border-color: rgba(255,100,100,.5); }
    .conversation-title { font-size: 14px; font-weight: 600; margin-bottom: 4px; line-height: 1.4; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .conversation-meta { font-size: 11px; opacity: 0.6; display: flex; gap: 12px; }
    .conversation-preview { margin-top: 8px; padding: 10px; background: rgba(0,0,0,.2); border-radius: 8px; max-height: 300px; overflow-y: auto; }
    .preview-message { padding: 8px 10px; margin-bottom: 6px; border-radius: 8px; font-size: 13px; line-height: 1.5; }
    .preview-message.user { background: rgba(80,120,255,.15); margin-left: 20%; }
    .preview-message.assistant { background: rgba(255,255,255,.08); margin-right: 20%; }
    .preview-message .role { font-size: 10px; opacity: 0.6; margin-bottom: 4px; text-transform: uppercase; }
    
    /* System Prompt Template List Styles */
    .system-prompt-item { background: rgba(255,255,255,.04); border: 1px solid rgba(255,255,255,.08); border-radius: 8px; padding: 10px 12px; margin-bottom: 8px; cursor: pointer; transition: all 0.2s; display: flex; justify-content: space-between; align-items: center; }
    .system-prompt-item:hover { background: rgba(80,120,255,.12); border-color: rgba(80,120,255,.3); }
    .system-prompt-item.active { background: rgba(80,120,255,.2); border-color: rgba(80,120,255,.4); box-shadow: 0 0 8px rgba(80,120,255,.2); }
    .system-prompt-item-name { flex: 1; font-size: 13px; font-weight: 500; }
    .system-prompt-item-actions { display: flex; gap: 6px; opacity: 0; transition: opacity 0.2s; margin-left: 8px; }
    .system-prompt-item:hover .system-prompt-item-actions { opacity: 1; }
    .system-prompt-delete-btn { padding: 6px 10px; background: rgba(255,100,100,.15); border: 1px solid rgba(255,100,100,.3); color: #ff6464; border-radius: 6px; font-size: 12px; cursor: pointer; transition: all 0.2s; white-space: nowrap; }
    .system-prompt-delete-btn:hover { background: rgba(255,100,100,.25); border-color: rgba(255,100,100,.5); }
    
    /* Language Selector Styles */
    .language-selector { display: flex; align-items: center; gap: 8px; }
    .language-selector select { padding: 6px 10px; border-radius: 8px; border: 1px solid rgba(255,255,255,.14); background: rgba(0,0,0,.25); color: #e7eefc; font-size: 12px; cursor: pointer; outline: none; transition: all 0.2s; }
    .language-selector select:hover { border-color: rgba(255,255,255,.24); background: rgba(0,0,0,.35); }
  </style>
  <script src="../i18n.js"></script>
  <script>
    // Ensure i18n is available before DOM parsing
    window.waitForI18N = new Promise((resolve) => {
      if (window.i18n) {
        resolve();
      } else {
        const checkInterval = setInterval(() => {
          if (window.i18n) {
            clearInterval(checkInterval);
            resolve();
          }
        }, 10);
      }
    });

    // Define changeLanguage globally so inline onchange can find it
    function changeLanguage(lang) {
      console.log('[UI] changeLanguage called with:', lang);
      if (!window.i18n || !window.i18n.translations || Object.keys(window.i18n.translations).length === 0) {
        console.error('[UI] i18n not ready yet, translations:', window.i18n ? window.i18n.translations : 'i18n missing');
        return;
      }
      window.i18n.setLanguage(lang);
      
      // Also save language to backend settings
      try {
        fetch('http://127.0.0.1:8787/settings', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ language: lang })
        }).then(res => {
          if (res.ok) console.log('[UI] Language saved to backend:', lang);
        }).catch(err => console.warn('[UI] Failed to save language to backend:', err));
      } catch (e) {
        console.warn('[UI] Failed to save language to backend:', e);
      }
      
      console.log('[UI] Language switched to:', lang);
    }
  </script>
</head>
<body>
  <header>
    <div>
      <div style="font-weight:700;" data-i18n="header.title">Engine External</div>
      <div class="badge">
        <span data-i18n="header.badge_local">Local-only</span> ‚Ä¢ <span data-i18n="header.badge_backend">Backend: 127.0.0.1:8787</span> ‚Ä¢ <span data-i18n="header.badge_version">Version</span> <span id="ver"></span>
      </div>
    </div>
    <div style="display: flex; align-items: center; gap: 16px;">
      <div class="language-selector">
        <label for="language-select" style="font-size: 12px; margin: 0; opacity: 0.7;">üåê</label>
        <select id="language-select" onchange="changeLanguage(this.value)">
          <option value="en" data-i18n="header.language_en">English</option>
          <option value="zh" data-i18n="header.language_zh" selected>‰∏≠Êñá</option>
        </select>
      </div>
      <div class="badge" data-i18n="header.badge_tip">Tip: Start backend first, then open chat.</div>
    </div>
  </header>

  <div class="wrap">
    <aside class="panel">
      <div class="card">
        <div style="display:flex; justify-content:space-between; align-items:center; cursor:pointer;" id="settings-toggle">
          <div style="font-weight:700;" data-i18n="settings.title">Settings</div>
          <span id="settings-arrow">‚ñº</span>
        </div>
        <div id="settings-content" style="display:none; margin-top:10px;">
          <div class="muted" style="margin-bottom:10px;" data-i18n="settings.description">Enter OpenAI-compatible base_url / api_key / model (stored locally only).</div>

          <label data-i18n="settings.base_url">Base URL (e.g. https://api.openai.com)</label>
          <input id="base_url" placeholder="https://api.openai.com" />

          <label style="margin-top:10px;" data-i18n="settings.api_key">API Key (leave empty to keep existing key)</label>
          <input id="api_key" type="password" data-i18n="settings.api_key" data-i18n-placeholder />

          <label style="margin-top:10px;" data-i18n="settings.model">Model</label>
          <select id="model" style="width:100%; box-sizing:border-box; border-radius:10px; border:1px solid rgba(255,255,255,.14); background:rgba(0,0,0,.25); color:#e7eefc; padding:10px; margin-bottom:8px;">
            <option value="" data-i18n="settings.model_select">-- Select Model --</option>
            <optgroup label="OpenAI Models">
              <option value="" data-i18n="settings.model_loading">Loading models from OpenAI...</option>
            </optgroup>
            <optgroup label="Custom">
              <option value="custom" data-i18n="settings.model_custom">Custom Model...</option>
            </optgroup>
          </select>
          <button id="refresh-models-btn" style="width:100%; padding:10px 16px; border-radius:10px; border:1px solid rgba(255,255,255,.14); background:rgba(0,0,0,.25); color:#e7eefc; cursor:pointer; margin-bottom:10px;" data-i18n="settings.refresh_models">Refresh Models</button>
          <div id="model-status" class="muted" style="font-size:12px; margin-bottom:10px; display:none;"></div>
          <input id="model_custom" data-i18n="settings.custom_model_placeholder" data-i18n-placeholder style="display:none; margin-top:6px;" />

          <label style="margin-top:10px;" data-i18n="settings.max_output_tokens">Max Output Tokens (response limit)</label>
          <input id="max_output_tokens" type="number" placeholder="800" min="100" max="32000" />

          <label style="margin-top:10px;" data-i18n="settings.temperature">Temperature (0.0 = deterministic, 1.0 = creative)</label>
          <input id="temperature" type="number" placeholder="0.7" min="0" max="2" step="0.1" />

          <div style="margin-top:12px; display:flex; align-items:center; gap:8px;">
            <input id="dev_mode" type="checkbox" style="width:auto; margin:0;" />
            <label for="dev_mode" style="margin:0; cursor:pointer;" data-i18n="settings.dev_mode_label">Developer Mode (show token usage)</label>
          </div>

          <!-- ÂØπËØùÂéÜÂè≤ÁÆ°ÁêÜ -->
          <div style="margin-top:16px; padding-top:12px; border-top:1px solid rgba(255,255,255,.08);">
            <label style="font-weight:600; margin-bottom:8px; display:block;" data-i18n="settings.history_strategy">ÂØπËØùÂéÜÂè≤Á≠ñÁï•</label>
            <div style="display:flex; flex-direction:column; gap:6px;">
              <label style="display:flex; align-items:center; gap:6px; cursor:pointer; margin:0;">
                <input type="radio" name="history_strategy" value="compression" style="width:auto; margin:0;" checked />
                <span data-i18n="settings.compression">Êô∫ËÉΩÂéãÁº© (Êé®Ëçê) ‚Äî Ëá™Âä®ÂéãÁº©ÊóßÂØπËØùÔºå‰øùÁïôÊ†∏ÂøÉ‰ø°ÊÅØ</span>
              </label>
              <div id="compression-options" style="display:block; margin-top:8px; margin-left:24px;">
                <label style="margin-bottom:6px; display:block;" data-i18n="settings.compression_threshold">ÂéãÁº©ÈòàÂÄº (tokensÔºåÂéÜÂè≤Ë∂ÖËøáÊ≠§ÂÄºÊó∂Ëß¶ÂèëÂéãÁº©)</label>
                <input id="compression_threshold" type="number" placeholder="1000" min="200" max="10000" />
                <label style="margin-top:6px; display:block;" data-i18n="settings.compression_target">ÂéãÁº©ÁõÆÊ†á (tokensÔºåÂéãÁº©ÂêéÁöÑÁõÆÊ†áÂ§ßÂ∞è)</label>
                <input id="compression_target" type="number" placeholder="200" min="50" max="2000" />
              </div>

              <label style="display:flex; align-items:center; gap:6px; cursor:pointer; margin:0; margin-top:8px;">
                <input type="radio" name="history_strategy" value="sliding_window" style="width:auto; margin:0;" />
                <span data-i18n="settings.sliding_window">ÊªëÂä®Á™óÂè£ (‰º†Áªü) ‚Äî Êà™Êñ≠Êó©ÊúüÂØπËØù</span>
              </label>
              <div id="sliding-window-options" style="display:none; margin-top:8px; margin-left:24px;">
                <label style="margin-bottom:6px; display:block;" data-i18n="settings.max_input_tokens">Max Input Tokens (context limit)</label>
                <input id="max_input_tokens" type="number" placeholder="2000" min="100" max="128000" />
                <div id="system_prompt_tokens_info" class="muted" style="font-size:12px; margin-top:2px;"></div>
              </div>
            </div>
          </div>

          <div style="display:flex; gap:10px; margin-top:12px;">
            <button id="save" data-i18n="settings.save">Save</button>
            <button id="health" data-i18n="settings.test_backend">Test Backend</button>
          </div>
        </div>
        <div id="status" class="muted" style="margin-top:10px;"></div>
      </div>

      <!-- System Prompt Panel -->
      <div class="card" style="margin-top:12px;">
        <div style="display:flex; justify-content:space-between; align-items:center;">
          <div style="font-weight:700;" data-i18n="system_prompt.title">System Prompt</div>
        </div>
        <button id="open-system-prompt-window" style="width:100%; margin-top:10px; padding:12px; font-size:14px;" data-i18n="system_prompt.edit_button">Edit System Prompt</button>
      </div>

      <!-- Conversation History Panel -->
      <div class="card" style="margin-top:12px;">
        <div style="display:flex; justify-content:space-between; align-items:center;">
          <div style="font-weight:700;" data-i18n="chat_history.title">Chat History</div>
        </div>
        <button id="open-conversations-window" style="width:100%; margin-top:10px; padding:12px; font-size:14px;" data-i18n="chat_history.button">Load Conversation History</button>
      </div>

      <!-- Memory Panel (Modal/Popup Mode) -->
      <div class="card" style="margin-top:12px;">
        <div style="display:flex; justify-content:space-between; align-items:center;">
          <div style="font-weight:700;" data-i18n="memory.title">Memory</div>
        </div>
        <button id="open-memory-window" style="width:100%; margin-top:10px; padding:12px; font-size:14px;" data-i18n="memory.button">Open Memory Window</button>
      </div>

      <!-- User Profile Card -->
      <div class="card" style="margin-top:12px;">
        <div style="display:flex; justify-content:space-between; align-items:center; cursor:pointer;" id="profile-toggle">
          <div style="font-weight:700;" data-i18n="user_profile.title">User Profile</div>
          <span id="profile-arrow" style="font-size:10px;">‚ñ∂</span>
        </div>
        <div id="profile-content" style="display:none; margin-top:10px;">
          <label data-i18n="user_profile.name">Name / Nickname</label>
          <input id="user_name" data-i18n="user_profile.name_placeholder" data-i18n-placeholder />
          
          <label style="margin-top:8px;" data-i18n="user_profile.age">Age</label>
          <input id="user_age" type="number" data-i18n="user_profile.age_placeholder" data-i18n-placeholder min="1" max="150" />
          
          <label style="margin-top:8px;" data-i18n="user_profile.gender">Gender</label>
          <select id="user_gender" style="width:100%; box-sizing:border-box; border-radius:10px; border:1px solid rgba(255,255,255,.14); background:rgba(0,0,0,.25); color:#e7eefc; padding:10px;">
            <option value="" data-i18n="user_profile.gender_not_specified">-- Not specified --</option>
            <option value="Male" data-i18n="user_profile.gender_male">Male</option>
            <option value="Female" data-i18n="user_profile.gender_female">Female</option>
            <option value="Other" data-i18n="user_profile.gender_other">Other</option>
          </select>
          
          <label style="margin-top:8px;" data-i18n="user_profile.occupation">Occupation</label>
          <input id="user_occupation" data-i18n="user_profile.occupation_placeholder" data-i18n-placeholder />
          
          <label style="margin-top:8px;" data-i18n="user_profile.location">Location</label>
          <input id="user_location" data-i18n="user_profile.location_placeholder" data-i18n-placeholder />
          
          <label style="margin-top:8px;" data-i18n="user_profile.bio">Short Bio</label>
          <textarea id="user_bio" data-i18n="user_profile.bio_placeholder" data-i18n-placeholder style="min-height:60px;"></textarea>
          
          <button id="save-profile" style="width:100%; margin-top:10px; padding:10px 12px; background:rgba(80,120,255,.3); border-color:rgba(80,120,255,.4); font-weight:500;" data-i18n="user_profile.save">Save Profile</button>
        </div>
      </div>
    </aside>

    <!-- System Prompt Modal Window -->
    <div id="system-prompt-modal" class="modal">
      <div class="modal-content" style="max-width: 700px;">
        <div class="modal-header">
          <h2 data-i18n="system_prompt.title">System Prompt</h2>
          <span class="modal-close" id="close-system-prompt-modal">&times;</span>
        </div>
        <div class="modal-body">
          <div class="muted" style="margin-bottom:12px; font-size:12px;" data-i18n="system_prompt.description">Choose an AI personality preset or create a custom one</div>
          
          <!-- Template List -->
          <div style="margin-bottom:16px;">
            <label style="font-size:12px; margin-bottom:6px; display:block; font-weight:600;" data-i18n="system_prompt.personality">AI Personality</label>
            <div id="system-prompt-template-list" style="background:rgba(0,0,0,.2); border-radius:6px; border:1px solid rgba(255,255,255,.14); max-height:200px; overflow-y:auto;">
              <div class="muted" style="text-align:center; padding:30px; font-size:12px;" data-i18n="system_prompt.loading">Loading personalities...</div>
            </div>
            <div id="template-status" class="muted" style="margin-top:6px; font-size:11px;"></div>
          </div>
          
          <!-- Prompt Editor Section (shown when any template selected) -->
          <div id="prompt-editor-section" style="display:none;">
            <label style="font-size:12px; margin-bottom:6px; display:block; font-weight:600;" data-i18n="system_prompt.content">AI Personality Content</label>
            <textarea id="system-prompt-input" data-i18n="system_prompt.content" data-i18n-placeholder style="width:100%; min-height:300px; max-height:500px; font-size:13px; box-sizing:border-box; border-radius:8px; border:1px solid rgba(255,255,255,.14); background:rgba(0,0,0,.25); color:#e7eefc; padding:12px; outline:none; font-family: monospace; resize: vertical;"></textarea>
            
            <label style="font-size:12px; margin-bottom:6px; display:block; margin-top:12px;" data-i18n="system_prompt.name">Personality Name</label>
            <input id="custom-prompt-name" type="text" data-i18n="system_prompt.name_placeholder" data-i18n-placeholder style="width:100%; padding:10px; border-radius:6px; border:1px solid rgba(255,255,255,.14); background:rgba(0,0,0,.25); color:#e7eefc; font-size:13px; outline:none; box-sizing:border-box;">
            
            <div style="display:flex; gap:10px; margin-top:12px;">
              <button id="save-system-prompt" style="flex:1; padding:10px; border-radius:8px; border:1px solid rgba(80,120,255,.2); background:rgba(80,120,255,.2); color:#e7eefc; font-size:13px; cursor:pointer; border-color:rgba(80,120,255,.4);" data-i18n="system_prompt.save">Save</button>
              <button id="reset-system-prompt" style="flex:1; padding:10px; border-radius:8px; border:1px solid rgba(255,255,255,.08); color:#e7eefc; font-size:13px; cursor:pointer;" data-i18n="system_prompt.clear">Clear</button>
            </div>
          </div>
          
          <div id="system-prompt-status" class="muted" style="margin-top:10px; font-size:11px;"></div>
        </div>
      </div>
    </div>

    <!-- Conversations Modal Window -->
    <div id="conversations-modal" class="modal">
      <div class="modal-content" style="max-width: 700px;">
        <div class="modal-header">
          <h2 data-i18n="chat_history.title">Conversation History</h2>
          <span class="modal-close" id="close-conversations-modal">&times;</span>
        </div>
        <div class="modal-body">
          <!-- Search bar and controls -->
          <div style="margin-bottom:12px; display:flex; gap:8px; align-items:center;">
            <input id="conversation-search" type="text" data-i18n="chat_history.search_placeholder" data-i18n-placeholder style="flex:1; box-sizing:border-box; border-radius:10px; border:1px solid rgba(255,255,255,.14); background:rgba(0,0,0,.25); color:#e7eefc; padding:10px; outline:none;" />
            <button id="new-conversation-btn" data-i18n-title="chat_history.new_conversation_title" title="Start a new conversation" style="padding:10px 12px; font-size:12px; background:rgba(100,200,100,.2); border-color:rgba(100,200,100,.4); white-space:nowrap;">‚ûï New Chat</button>
            <button id="upload-conversation-zip-btn" data-i18n-title="chat_history.upload_zip_title" title="Upload a zip data package to import conversations" style="padding:10px 12px; font-size:12px; background:rgba(80,200,120,.2); border-color:rgba(80,200,120,.4); white-space:nowrap;">üì¶ Upload Zip</button>
            <button id="reload-conversations-btn" data-i18n-title="chat_history.reload_title" title="Reload from conversations.json" style="padding:10px 12px; font-size:12px; background:rgba(255,180,80,.2); border-color:rgba(255,180,80,.4); white-space:nowrap;">üîÑ Reload</button>
            <input type="file" id="zip-file-input" accept=".zip" style="display:none;" />
          </div>
          
          <!-- Conversation list -->
          <div id="conversation-list" style="max-height: 55vh; overflow-y: auto;">
            <div class="muted" style="text-align:center; padding:30px;" data-i18n="chat_history.empty">Loading conversations...</div>
          </div>
          
          <!-- Status -->
          <div id="conversation-status" class="muted" style="margin-top:10px; font-size:11px;"></div>
        </div>
      </div>
    </div>

    <!-- Custom Confirm Dialog -->
    <div id="confirm-dialog" class="modal" style="display:none; z-index:9999;">
      <div id="confirm-modal-content" class="modal-content" style="max-width: 400px; background:rgba(20,30,60,.95); border:1px solid rgba(80,120,255,.3); display:flex; flex-direction:column;">
        <div class="modal-body" style="padding:10px; flex:1; display:flex; flex-direction:column; justify-content:space-between;">
          <h3 id="confirm-title" style="display:none;"></h3>
          <p id="confirm-message" style="margin:0 0 12px 0; font-size:13px; color:rgba(231,238,252,.9); line-height:1.4; text-align:center; word-wrap:break-word;"></p>
          <div style="display:flex; gap:8px; justify-content:center; flex-shrink:0;">
            <button id="confirm-cancel" style="padding:6px 16px; border-radius:4px; border:1px solid rgba(255,255,255,.14); background:rgba(255,255,255,.08); color:#e7eefc; font-size:12px; cursor:pointer;">ÂèñÊ∂à</button>
            <button id="confirm-ok" style="padding:6px 16px; border-radius:4px; border:1px solid rgba(80,120,255,.4); background:rgba(80,120,255,.3); color:#e7eefc; font-size:12px; cursor:pointer;">Á°ÆËÆ§</button>
          </div>
        </div>
      </div>
    </div>

    <!-- Memory Modal Window -->

    <div id="memory-modal" class="modal">
      <div class="modal-content">
        <div class="modal-header">
          <h2 data-i18n="memory.title">Memory</h2>
          <span class="modal-close" id="close-memory-modal">&times;</span>
        </div>
        <div class="modal-body">
          <!-- Plugin Selection (Hidden, always using vector memory) -->
          <input type="hidden" id="memory-plugin-select" value="vector">
          <div id="plugin-info" class="muted" style="font-size:11px; padding:6px; background:rgba(255,255,255,.04); border-radius:4px; margin-bottom:8px; display:none;"></div>
          <div id="plugin-features" style="display:none; gap:4px; flex-wrap:wrap;"></div>
          
          <!-- Tab Switching -->
          <div class="tab-buttons">
            <div class="tab-btn active" data-tab="memories">Memories</div>
            <button id="refresh-memory" style="padding:8px 12px; font-size:12px; flex:0.5;">Refresh</button>
          </div>

          <!-- Memory List -->
          <div id="memories-tab" class="tab-content">
            <!-- Core Memory -->
            <div style="margin-bottom:16px;">
              <div style="font-weight:600; font-size:12px; margin-bottom:8px; color:#80d8ff;">‚≠ê Core Memory</div>
              <div id="core-memory-list" style="background:rgba(0,0,0,.2); border-radius:6px; padding:8px; min-height:60px; max-height:150px; overflow-y:auto; border:1px solid rgba(128,216,255,.2);">
                <div class="muted" style="text-align:center; padding:20px; font-size:12px;">No core memories yet</div>
              </div>
            </div>
            
            <!-- Memory Library -->
            <div>
              <div style="font-weight:600; font-size:12px; margin-bottom:8px; color:#b3e5fc;">üìö Memory Library</div>
              
              <!-- Memory list -->
              <div id="memory-library-list" style="background:rgba(0,0,0,.2); border-radius:6px; padding:8px; min-height:60px; max-height:200px; overflow-y:auto; border:1px solid rgba(179,229,252,.2);">
                <div class="muted" style="text-align:center; padding:20px; font-size:12px;">Click refresh to load memories...</div>
              </div>
            </div>
          </div>

          <!-- Add Memory -->
          <div style="margin-top:16px; padding-top:12px; border-top:1px solid rgba(255,255,255,.08);">
            <div style="font-weight:600; font-size:13px; margin-bottom:8px;">Add Memory</div>
            <textarea id="new-memory" data-i18n="memory.new_memory" data-i18n-placeholder style="width:100%; min-height:60px; font-size:12px; box-sizing:border-box; border-radius:8px; border:1px solid rgba(255,255,255,.14); background:rgba(0,0,0,.25); color:#e7eefc; padding:8px; outline:none;"></textarea>
            <div style="display:flex; gap:6px; margin-top:8px;">
              <button id="add-memory" style="flex:1; padding:8px; border-radius:8px; border:1px solid rgba(255,255,255,.14); background:rgba(80,120,255,.2); color:#e7eefc; font-size:12px; cursor:pointer;">Add</button>
              <button id="auto-select-core" data-i18n-title="memory.auto_core_title" style="flex:1; padding:8px; border-radius:8px; border:1px solid rgba(255,200,100,.3); background:rgba(255,200,100,.15); color:#e7eefc; font-size:12px; cursor:pointer;" title="Let AI select important memories for Core">ü§ñ Auto Core</button>
              <button id="clear-memory" style="padding:8px 12px; border-radius:8px; border:1px solid rgba(255,255,255,.14); background:rgba(255,80,80,.2); color:#e7eefc; font-size:12px; cursor:pointer;">Clear</button>
            </div>
            <div id="memory-status" class="muted" style="margin-top:8px; font-size:11px;"></div>
          </div>
        </div>
      </div>
    </div>

    <main class="main">
      <!-- Loaded conversation header (top) -->
      <div id="loaded-conv-header" style="display:none; padding:8px 12px; background:rgba(80,120,255,.08); border-bottom:1px solid rgba(80,120,255,.2); border-radius:6px 6px 0 0; margin-bottom:0;">
        <div style="display:flex; gap:8px; align-items:center; font-size:12px;">
          <label style="color:rgba(255,255,255,.6); white-space:nowrap;">Title:</label>
          <input id="loaded-conv-title-header" type="text" placeholder="Conversation title..." style="flex:1; border-radius:4px; border:1px solid rgba(255,255,255,.1); background:rgba(0,0,0,.2); color:#e7eefc; padding:4px 8px; font-size:12px; outline:none;" />
          <span id="loaded-conv-meta-header" class="muted" style="font-size:10px; white-space:nowrap;"></span>
        </div>
      </div>
      
      <div class="chatlog" id="chatlog"></div>

      <div class="card">
        <!-- Loaded conversation footer (bottom) -->
        <div id="loaded-conv-footer" style="display:none; padding:6px 10px; background:rgba(80,120,255,.08); border:1px solid rgba(80,120,255,.2); border-radius:4px; margin-bottom:10px;">
          <div style="display:flex; gap:8px; align-items:center; justify-content:space-between; font-size:11px;">
            <span id="loaded-conv-meta-footer" class="muted"></span>
          </div>
        </div>
        
        <label data-i18n="main_chat.message_placeholder">Message</label>
        <textarea id="msg" data-i18n="main_chat.message_placeholder" data-i18n-placeholder></textarea>
        <div style="display:flex; gap:10px; margin-top:10px;">
          <button id="send" data-i18n="main_chat.send">Send</button>
          <button id="clear">Clear</button>
        </div>
        <div id="meta" class="muted" style="margin-top:10px;"></div>
      </div>
    </main>
  </div>

<script>
  // Get version from main process via IPC
  async function initializeUI() {
    if (window.aurora && typeof window.aurora.getAppVersion === 'function') {
      const version = await window.aurora.getAppVersion();
      const verElement = document.getElementById('ver');
      if (verElement) {
        verElement.textContent = version;
      }
    }
  }
  
  // Initialize on DOM ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initializeUI);
  } else {
    initializeUI();
  }
  
  const chatlog = document.getElementById("chatlog");
  const status = document.getElementById("status");
  const meta = document.getElementById("meta");

  // Settings collapse/expand toggle
  document.getElementById("settings-toggle").onclick = () => {
    const content = document.getElementById("settings-content");
    const arrow = document.getElementById("settings-arrow");
    if (content.style.display === "none") {
      content.style.display = "block";
      arrow.textContent = "‚ñ≤";
    } else {
      content.style.display = "none";
      arrow.textContent = "‚ñº";
    }
  };

  // ÂØπËØùÂéÜÂè≤Á≠ñÁï•ÂàáÊç¢ÔºöÊòæÁ§∫/ÈöêËóèÁõ∏Â∫îÈÄâÈ°π
  function toggleHistoryStrategyOptions(strategy) {
    const compressionOpts = document.getElementById("compression-options");
    const slidingOpts = document.getElementById("sliding-window-options");
    if (strategy === "compression") {
      compressionOpts.style.display = "block";
      slidingOpts.style.display = "none";
    } else {
      compressionOpts.style.display = "none";
      slidingOpts.style.display = "block";
    }
  }
  document.querySelectorAll('input[name="history_strategy"]').forEach(r => {
    r.addEventListener("change", e => toggleHistoryStrategyOptions(e.target.value));
  });

  // User Profile collapse/expand toggle
  document.getElementById("profile-toggle").onclick = () => {
    const content = document.getElementById("profile-content");
    const arrow = document.getElementById("profile-arrow");
    if (content.style.display === "none") {
      content.style.display = "block";
      arrow.textContent = "‚ñº";
    } else {
      content.style.display = "none";
      arrow.textContent = "‚ñ∂";
    }
  };


  // Message index for tracking
  let messageIndex = 0;
  const messageMap = new Map(); // Map of messageId -> {role, content, element}
  
  function addBubble(text, who, tokenInfo = null) {
    const div = document.createElement("div");
    div.className = "bubble " + (who === "user" ? "u" : "a");
    const messageId = `msg_${messageIndex++}`;
    div.dataset.messageId = messageId;
    
    // Create wrapper for content and actions
    const contentDiv = document.createElement("div");
    contentDiv.className = "bubble-content";
    contentDiv.textContent = text;
    div.appendChild(contentDiv);
    
    // Add edit button
    const actionsDiv = document.createElement("div");
    actionsDiv.className = "bubble-actions";
    
    const editBtn = document.createElement("button");
    editBtn.className = "bubble-edit-btn";
    editBtn.textContent = "‚úèÔ∏è Edit";
    editBtn.onclick = (e) => {
      e.stopPropagation();
      startEditMessage(messageId, div);
    };
    actionsDiv.appendChild(editBtn);
    div.appendChild(actionsDiv);
    
    // Store message info
    messageMap.set(messageId, {
      role: who,
      content: text,
      element: div,
      tokenInfo: tokenInfo
    });
    
    // Â¶ÇÊûúÊòØassistantÊ∂àÊÅØ‰∏îÂºÄÂêØ‰∫ÜÂºÄÂèëËÄÖÊ®°ÂºèÔºåÊòæÁ§∫tokenËØ¶ÊÉÖ
    if (who === "assistant" && devModeEnabled && tokenInfo) {
      const tokenDiv = document.createElement("div");
      tokenDiv.className = "muted";
      tokenDiv.style.cssText = "font-size:11px; margin-top:6px; padding-top:6px; border-top:1px solid rgba(255,255,255,0.1);";
      tokenDiv.innerHTML = `<strong>Token Usage:</strong> prompt=${tokenInfo.prompt_tokens || 0}, completion=${tokenInfo.completion_tokens || 0}, total=${tokenInfo.total_tokens || 0}<br>` +
        `<strong>Estimated:</strong> input=${tokenInfo.estimated_input_tokens || 0}, system_prompt=${tokenInfo.system_prompt_tokens || 0}`;
      div.appendChild(tokenDiv);
    }
    
    chatlog.appendChild(div);
    chatlog.scrollTop = chatlog.scrollHeight;
  }
  
  // Start editing a message
  function startEditMessage(messageId, bubbleEl) {
    const msgData = messageMap.get(messageId);
    if (!msgData) return;
    
    // Create textarea for editing
    const textarea = document.createElement('textarea');
    textarea.className = 'bubble-textarea';
    textarea.value = msgData.content;
    
    // Replace content with textarea
    bubbleEl.innerHTML = '';
    bubbleEl.appendChild(textarea);
    
    // Create save/cancel buttons
    const btnDiv = document.createElement('div');
    btnDiv.style.cssText = 'display: flex; gap: 6px; margin-top: 6px;';
    
    const saveBtn = document.createElement('button');
    saveBtn.className = 'bubble-save-btn';
    saveBtn.textContent = 'üíæ Save';
    saveBtn.onclick = () => saveEditMessage(messageId, textarea.value);
    
    const cancelBtn = document.createElement('button');
    cancelBtn.className = 'bubble-cancel-btn';
    cancelBtn.textContent = '‚úï Cancel';
    cancelBtn.onclick = () => cancelEditMessage(messageId);
    
    btnDiv.appendChild(saveBtn);
    btnDiv.appendChild(cancelBtn);
    bubbleEl.appendChild(btnDiv);
    
    // Focus textarea
    textarea.focus();
    textarea.select();
  }
  
  // Save edited message
  async function saveEditMessage(messageId, newContent) {
    const msgData = messageMap.get(messageId);
    if (!msgData) return;
    
    const newContentTrimmed = newContent.trim();
    if (!newContentTrimmed) {
      alert('Message cannot be empty');
      return;
    }
    
    try {
      // Update message in map
      msgData.content = newContentTrimmed;
      messageMap.set(messageId, msgData);
      
      // Update UI to show new content
      const bubbleEl = msgData.element;
      const contentDiv = document.createElement('div');
      contentDiv.className = 'bubble-content';
      contentDiv.textContent = newContentTrimmed;
      
      bubbleEl.innerHTML = '';
      bubbleEl.appendChild(contentDiv);
      
      // Recreate edit button
      const actionsDiv = document.createElement('div');
      actionsDiv.className = 'bubble-actions';
      const editBtn = document.createElement('button');
      editBtn.className = 'bubble-edit-btn';
      editBtn.textContent = '‚úèÔ∏è Edit';
      editBtn.onclick = (e) => {
        e.stopPropagation();
        startEditMessage(messageId, bubbleEl);
      };
      actionsDiv.appendChild(editBtn);
      bubbleEl.appendChild(actionsDiv);
      
      // Re-add token info if exists
      if (msgData.tokenInfo && msgData.role === 'assistant' && devModeEnabled) {
        const tokenDiv = document.createElement('div');
        tokenDiv.className = 'muted';
        tokenDiv.style.cssText = 'font-size:11px; margin-top:6px; padding-top:6px; border-top:1px solid rgba(255,255,255,0.1);';
        tokenDiv.innerHTML = `<strong>Token Usage:</strong> prompt=${msgData.tokenInfo.prompt_tokens || 0}, completion=${msgData.tokenInfo.completion_tokens || 0}, total=${msgData.tokenInfo.total_tokens || 0}<br>` +
          `<strong>Estimated:</strong> input=${msgData.tokenInfo.estimated_input_tokens || 0}, system_prompt=${msgData.tokenInfo.system_prompt_tokens || 0}`;
        bubbleEl.appendChild(tokenDiv);
      }
      
      // Save to backend
      if (currentLoadedConversation) {
        await saveCurrentConversation();
      }
      
      console.log('[DEBUG] Message edited and saved:', messageId);
    } catch (e) {
      console.error('Failed to save edited message:', e);
      alert('Failed to save: ' + e.message);
    }
  }
  
  // Cancel editing and restore original content
  function cancelEditMessage(messageId) {
    const msgData = messageMap.get(messageId);
    if (!msgData) return;
    
    const bubbleEl = msgData.element;
    const contentDiv = document.createElement('div');
    contentDiv.className = 'bubble-content';
    contentDiv.textContent = msgData.content;
    
    bubbleEl.innerHTML = '';
    bubbleEl.appendChild(contentDiv);
    
    // Recreate edit button
    const actionsDiv = document.createElement('div');
    actionsDiv.className = 'bubble-actions';
    const editBtn = document.createElement('button');
    editBtn.className = 'bubble-edit-btn';
    editBtn.textContent = '‚úèÔ∏è Edit';
    editBtn.onclick = (e) => {
      e.stopPropagation();
      startEditMessage(messageId, bubbleEl);
    };
    actionsDiv.appendChild(editBtn);
    bubbleEl.appendChild(actionsDiv);
    
    // Re-add token info if exists
    if (msgData.tokenInfo && msgData.role === 'assistant' && devModeEnabled) {
      const tokenDiv = document.createElement('div');
      tokenDiv.className = 'muted';
      tokenDiv.style.cssText = 'font-size:11px; margin-top:6px; padding-top:6px; border-top:1px solid rgba(255,255,255,0.1);';
      tokenDiv.innerHTML = `<strong>Token Usage:</strong> prompt=${msgData.tokenInfo.prompt_tokens || 0}, completion=${msgData.tokenInfo.completion_tokens || 0}, total=${msgData.tokenInfo.total_tokens || 0}<br>` +
        `<strong>Estimated:</strong> input=${msgData.tokenInfo.estimated_input_tokens || 0}, system_prompt=${msgData.tokenInfo.system_prompt_tokens || 0}`;
      bubbleEl.appendChild(tokenDiv);
    }
  }

  // API function to call backend endpoints
  async function api(path, methodOrOptions="GET", body=null) {
    const url = "http://127.0.0.1:8787" + path;
    let opt;
    
    // Support both old format: api(path, method, body) and new format: api(path, options)
    if (typeof methodOrOptions === 'object' && methodOrOptions !== null) {
      // New format: options object
      opt = methodOrOptions;
      if (!opt.headers) opt.headers = {};
      if (!opt.headers['Content-Type']) opt.headers['Content-Type'] = 'application/json';
    } else {
      // Old format: (path, method, body)
      const method = methodOrOptions;
      opt = { method, headers: { "Content-Type": "application/json" } };
      if (body) opt.body = JSON.stringify(body);
    }
    
    const res = await fetch(url, opt);
    if (!res.ok) throw new Error(await res.text());
    return await res.json();
  }

  // ==================== Custom Confirm Dialog ====================
  const confirmDialog = document.getElementById('confirm-dialog');
  const confirmModalContent = document.getElementById('confirm-modal-content');
  const confirmTitle = document.getElementById('confirm-title');
  const confirmMessage = document.getElementById('confirm-message');
  const confirmOkBtn = document.getElementById('confirm-ok');
  const confirmCancelBtn = document.getElementById('confirm-cancel');
  
  async function showConfirm(message) {
    return new Promise((resolve) => {
      confirmTitle.style.display = 'none';
      confirmMessage.textContent = message;
      confirmDialog.style.display = 'flex';
      
      // ÈáçÁΩÆ max-height ‰ª•ÂÖÅËÆ∏ÂÜÖÂÆπÊ≠£Á°ÆÂ∏ÉÂ±Ä
      confirmModalContent.style.maxHeight = 'none';
      
      // ‰ΩøÁî® setTimeout Âú®‰∏ã‰∏ÄÂ∏ßÈáçÊñ∞ËÆ°ÁÆóÂ∞∫ÂØ∏
      setTimeout(() => {
        const messageEl = confirmMessage;
        const scrollHeight = messageEl.scrollHeight;
        const contentPadding = 30; // modal-body padding
        const buttonHeight = 36; // ‰º∞ËÆ°ÊåâÈíÆÈ´òÂ∫¶ + margin
        const margin = 12; // message Âíå button ‰πãÈó¥ÁöÑ margin
        
        // ËÆ°ÁÆóÊâÄÈúÄÁöÑÊÄªÈ´òÂ∫¶ÔºåÊúÄÂ∞è 120pxÔºåÊúÄÂ§ß 400px
        let requiredHeight = contentPadding + scrollHeight + margin + buttonHeight;
        let maxHeight = Math.min(Math.max(requiredHeight, 120), 400);
        
        confirmModalContent.style.maxHeight = maxHeight + 'px';
      }, 0);
      
      // Create handlers that resolve the promise and cleanup
      const handleOk = () => {
        confirmDialog.style.display = 'none';
        confirmOkBtn.removeEventListener('click', handleOk);
        confirmCancelBtn.removeEventListener('click', handleCancel);
        confirmDialog.removeEventListener('click', handleBackgroundClick);
        resolve(true);
      };
      
      const handleCancel = () => {
        confirmDialog.style.display = 'none';
        confirmOkBtn.removeEventListener('click', handleOk);
        confirmCancelBtn.removeEventListener('click', handleCancel);
        confirmDialog.removeEventListener('click', handleBackgroundClick);
        resolve(false);
      };
      
      const handleBackgroundClick = (e) => {
        if (e.target === confirmDialog) {
          handleCancel();
        }
      };
      
      confirmOkBtn.addEventListener('click', handleOk);
      confirmCancelBtn.addEventListener('click', handleCancel);
      confirmDialog.addEventListener('click', handleBackgroundClick);
    });
  }

  // Global dev mode flag
  let devModeEnabled = false;

  async function loadSettings() {
    try {
      const s = await api("/settings");
      document.getElementById("base_url").value = s.base_url || "";
      document.getElementById("api_key").value = "";
      // Set model dropdown menu
      const modelSelect = document.getElementById("model");
      const modelCustom = document.getElementById("model_custom");
      const savedModel = s.model || "";
      // Check if preset model
      let found = false;
      for (let opt of modelSelect.options) {
        if (opt.value === savedModel) {
          modelSelect.value = savedModel;
          found = true;
          break;
        }
      }
      if (!found && savedModel) {
        modelSelect.value = "custom";
        modelCustom.style.display = "block";
        modelCustom.value = savedModel;
      }
      
      // Load token limits
      document.getElementById("max_input_tokens").value = s.max_input_tokens || "2000";
      document.getElementById("max_output_tokens").value = s.max_output_tokens || "800";
      
      // Load temperature
      document.getElementById("temperature").value = s.temperature !== undefined ? s.temperature : "0.7";
      
      // Load dev mode
      document.getElementById("dev_mode").checked = s.dev_mode || false;
      devModeEnabled = s.dev_mode || false;
      
      // Load history strategy
      const strategy = s.history_strategy || "compression";
      document.querySelector(`input[name="history_strategy"][value="${strategy}"]`).checked = true;
      document.getElementById("compression_threshold").value = s.compression_threshold || "1000";
      document.getElementById("compression_target").value = s.compression_target || "200";
      toggleHistoryStrategyOptions(strategy);
      
      // Update system prompt tokens info
      if (s.system_prompt) {
        updateSystemPromptTokensInfo(s.system_prompt);
      }
      
      status.textContent = "Loaded settings (api_key hidden)";
      
      // Load and apply language setting
      if (s.language && window.i18n) {
        const langSelect = document.getElementById('language-select');
        if (langSelect) langSelect.value = s.language;
        window.i18n.setLanguage(s.language);
      }
      
      // Try to fetch OpenAI models if we have API key
      if (s.api_key && s.base_url) {
        fetchOpenAIModels(s.api_key, s.base_url);
      }
    } catch (e) {
      status.textContent = "Backend not connected. Please start the backend.";
    }
  }

  // Fetch OpenAI models list via backend
  async function fetchOpenAIModels(apiKey, baseUrl) {
    const statusEl = document.getElementById("model-status");
    const modelSelect = document.getElementById("model");
    
    try {
      statusEl.textContent = "‚è≥ Fetching models...";
      statusEl.style.display = "block";
      
      // Call backend endpoint instead of OpenAI directly (to avoid CORS issues)
      const response = await api("/models/fetch", {
        method: "POST"
      });
      
      if (response.error) {
        let errorMsg = `‚ùå ${response.error}`;
        if (response.hint) {
          errorMsg += ` (${response.hint})`;
        }
        statusEl.textContent = errorMsg;
        statusEl.style.display = "block";
        console.error("Error fetching models:", response);
        return;
      }
      
      const models = response.models || [];
      
      if (models.length === 0) {
        statusEl.textContent = "‚ö†Ô∏è No models found";
        statusEl.style.display = "block";
        return;
      }
      
      // Clear existing options (except the custom option)
      const openaiOptgroup = modelSelect.querySelector("optgroup[label='OpenAI Models']");
      openaiOptgroup.innerHTML = '';
      
      // Add fetched models
      models.forEach(model => {
        const option = document.createElement("option");
        option.value = model.id;
        option.textContent = model.id;
        openaiOptgroup.appendChild(option);
      });
      
      statusEl.textContent = `‚úì Loaded ${models.length} models from OpenAI`;
      statusEl.style.display = "block";
      
    } catch (e) {
      statusEl.textContent = `‚ùå Failed: ${e.message}`;
      statusEl.style.display = "block";
      console.error("Error fetching models:", e);
    }
  }

  // Refresh models button
  document.getElementById("refresh-models-btn").onclick = async () => {
    const statusEl = document.getElementById("model-status");
    const baseUrl = document.getElementById("base_url").value.trim();
    const apiKey = document.getElementById("api_key").value.trim();
    
    if (!baseUrl) {
      statusEl.textContent = "‚ùå Please enter Base URL first";
      statusEl.style.display = "block";
      return;
    }
    
    statusEl.textContent = "‚è≥ Fetching models...";
    statusEl.style.display = "block";
    await fetchOpenAIModels(apiKey, baseUrl);
  };

  // Model dropdown: show input when 'custom' is selected
  document.getElementById("model").onchange = () => {
    const modelSelect = document.getElementById("model");
    const modelCustom = document.getElementById("model_custom");
    if (modelSelect.value === "custom") {
      modelCustom.style.display = "block";
      modelCustom.focus();
    } else {
      modelCustom.style.display = "none";
      modelCustom.value = "";
    }
  };

  // Get currently selected model
  function getSelectedModel() {
    const modelSelect = document.getElementById("model");
    const modelCustom = document.getElementById("model_custom");
    if (modelSelect.value === "custom") {
      return modelCustom.value.trim();
    }
    return modelSelect.value;
  }

  document.getElementById("save").onclick = async () => {
    const status = document.getElementById("status");
    try {
      const base_url = document.getElementById("base_url").value.trim();
      const api_key = document.getElementById("api_key").value.trim();
      const model = getSelectedModel();
      const max_input_tokens = parseInt(document.getElementById("max_input_tokens").value) || 2000;
      const max_output_tokens = parseInt(document.getElementById("max_output_tokens").value) || 800;
      const temperature = parseFloat(document.getElementById("temperature").value) || 0.7;
      const dev_mode = document.getElementById("dev_mode").checked;
      const history_strategy = document.querySelector('input[name="history_strategy"]:checked').value;
      const compression_threshold = parseInt(document.getElementById("compression_threshold").value) || 1000;
      const compression_target = parseInt(document.getElementById("compression_target").value) || 200;
      
      // Ëé∑ÂèñÂΩìÂâçËÆæÁΩÆÔºå‰øùÁïôÁî®Êà∑Êú™‰øÆÊîπÁöÑÂ≠óÊÆµ
      const current = await api("/settings");
      
      // Âè™Êõ¥Êñ∞Áî®Êà∑Â°´ÂÜôÁöÑÂ≠óÊÆµ
      const updates = {
        provider: "openai_compatible",
        base_url: base_url || current.base_url,
        model: model || current.model,
        max_input_tokens,
        max_output_tokens,
        temperature,
        dev_mode,
        history_strategy,
        compression_threshold,
        compression_target,
        language: window.i18n ? window.i18n.getLanguage() : 'zh'
      };
      
      // Âè™ÊúâÁî®Êà∑Êñ∞Â°´ÂÜô‰∫ÜAPI keyÊâçÊõ¥Êñ∞ÔºàÈÅøÂÖç‰øùÂ≠òËôöÂÅáÁöÑ"********"Ôºâ
      if (api_key) {
        updates.api_key = api_key;
      } else if (current.api_key && current.api_key !== "********") {
        // ‰øùÁïôÁé∞ÊúâÁöÑÁúüÂÆûAPI key
        updates.api_key = current.api_key;
      }
      
      // È™åËØÅtokenÂíåtemperatureËåÉÂõ¥Ôºà‰ΩÜ‰∏çÂº∫Âà∂base_urlÂíåmodelÔºâ
      if (max_input_tokens < 100 || max_input_tokens > 128000) {
        status.textContent = "Max Input Tokens must be between 100 and 128000";
        return;
      }
      
      if (max_output_tokens < 100 || max_output_tokens > 32000) {
        status.textContent = "Max Output Tokens must be between 100 and 32000";
        return;
      }
      
      if (temperature < 0 || temperature > 2) {
        status.textContent = "Temperature must be between 0 and 2";
        return;
      }
      
      status.textContent = "Saving...";
      await api("/settings", "POST", updates);
      devModeEnabled = dev_mode;
      status.textContent = "Settings saved successfully!";
    } catch (e) {
      status.textContent = "Save failed: " + e.message;
    }
  };


  document.getElementById("health").onclick = async () => {
    const status = document.getElementById("status");
    try {
      status.textContent = "Testing...";
      const result = await api("/health");
      status.textContent = "‚úì Backend OK";
    } catch (e) {
      status.textContent = "‚úó Backend connection failed: " + e.message;
    }
  };

  // Send message function
  async function sendMessage() {
    const msg = document.getElementById("msg").value.trim();
    if (!msg) return;
    document.getElementById("msg").value = "";
    addBubble(msg, "user");
    meta.textContent = "Waiting for reply...";
    try {
      // Ëé∑ÂèñÁî®Êà∑‰ø°ÊÅØ
      const userProfile = getUserProfile();
      
      const out = await api("/chat", "POST", { 
        user_message: msg, 
        session_id: "default",
        user_profile: userProfile
      });
      addBubble(out.assistant_message, "assistant", out.token_info);
      
      // ÊûÑÂª∫Áä∂ÊÄÅ‰ø°ÊÅØ
      let statusText = `Mode=${out.mode} ‚Ä¢ Memory cards=${out.used_memory_cards.length}`;
      
      // Â¶ÇÊûúÂºÄÂêØ‰∫ÜÂºÄÂèëËÄÖÊ®°ÂºèÔºåÊòæÁ§∫token‰ø°ÊÅØ
      if (devModeEnabled && out.token_info) {
        const ti = out.token_info;
        statusText += ` ‚Ä¢ Tokens: prompt=${ti.prompt_tokens || 0}, completion=${ti.completion_tokens || 0}, total=${ti.total_tokens || 0}`;
        statusText += ` (est. input=${ti.estimated_input_tokens || 0}, system=${ti.system_prompt_tokens || 0})`;
      }
      if (devModeEnabled && out.compression_state) {
        const cs = out.compression_state;
        statusText += ` ‚Ä¢ History: ${out.history_strategy || 'unknown'}`;
        if (cs.has_compressed) {
          statusText += ` (compressed=${cs.compressed_tokens}t, msgs=${cs.current_messages})`;
        }
      }
      
      meta.textContent = statusText;
      
      // Auto-save conversation after each chat
      // If no conversation is loaded, create a new one with auto-generated title
      if (!currentLoadedConversation) {
        // Create new conversation with first message as title
        const autoTitle = msg.substring(0, 50) + (msg.length > 50 ? '...' : '');
        currentLoadedConversation = {
          conversation_id: `engine_${Date.now()}`,
          title: autoTitle,
          messages: []
        };
        // Show the header/footer
        loadedConvHeader.style.display = 'block';
        loadedConvFooter.style.display = 'block';
        loadedConvTitleHeader.value = autoTitle;
        loadedConvMetaHeader.textContent = `ID: ${currentLoadedConversation.conversation_id}`;
      }
      
      console.log('[DEBUG] Auto-saving conversation after chat...');
      await saveCurrentConversation();
      
    } catch (e) {
      addBubble("Backend error: " + e.message, "assistant");
      meta.textContent = "Request failed";
    }
  }

  // Send button click
  document.getElementById("send").onclick = sendMessage;

  // Input box keyboard event: Enter to send, Shift+Enter to newline
  document.getElementById("msg").onkeydown = (e) => {
    if (e.key === "Enter") {
      if (e.shiftKey) {
        // Shift+Enter: newline (default behavior)
        return;
      } else {
        // Enter: send
        e.preventDefault();
        sendMessage();
      }
    }
  };

  document.getElementById("clear").onclick = async () => {
    chatlog.innerHTML = "";
    meta.textContent = "Clearing...";
    
    // Reset message tracking
    messageIndex = 0;
    messageMap.clear();
    
    // Hide loaded conversation UI
    loadedConvHeader.style.display = 'none';
    loadedConvFooter.style.display = 'none';
    currentLoadedConversation = null;
    
    try {
      await api("/clear-history", "POST", { session_id: "default" });
      meta.textContent = "Chat history cleared";
    } catch (e) {
      meta.textContent = "Frontend cleared, backend clear failed";
    }
  };

  loadSettings();

  // ==================== System Prompt Modal Window ====================
  const systemPromptModal = document.getElementById('system-prompt-modal');
  const openSystemPromptBtn = document.getElementById('open-system-prompt-window');
  const closeSystemPromptBtn = document.getElementById('close-system-prompt-modal');
  const systemPromptInput = document.getElementById('system-prompt-input');
  const customPromptName = document.getElementById('custom-prompt-name');
  const saveSystemPromptBtn = document.getElementById('save-system-prompt');
  const resetSystemPromptBtn = document.getElementById('reset-system-prompt');
  const systemPromptStatus = document.getElementById('system-prompt-status');
  const systemPromptTemplateList = document.getElementById('system-prompt-template-list');
  const templateStatus = document.getElementById('template-status');
  const promptEditorSection = document.getElementById('prompt-editor-section');
  
  // ÂΩìÂâçÈÄâ‰∏≠ÁöÑÊ®°ÊùøIDÂíåÂÜÖÂÆπ
  let currentSelectedTemplateId = null;
  let currentTemplateContent = '';
  let currentIsBuiltIn = false;  // Ê†áËÆ∞ÂΩìÂâçÈÄâ‰∏≠ÁöÑÊòØÂê¶‰∏∫ÂÜÖÁΩÆÊ®°Êùø
  
  // Âä†ËΩΩÊ®°ÊùøÂàóË°®
  async function loadTemplatesList() {
    try {
      const data = await api('/settings/system-prompt/templates');
      const templates = data.templates || [];
      
      // ÊûÑÂª∫ÂàóË°®HTML
      let listHtml = '';
      
      // ÊûÑÂª∫ÊâÄÊúâÊ®°ÊùøÔºàÂÜÖÁΩÆÂíåËá™ÂÆö‰πâÔºâ
      templates.forEach(template => {
        const isBuiltIn = template.is_builtin;
        // Âè™ÊúâËá™ÂÆö‰πâÊ®°ÊùøÊâçÊòæÁ§∫Âà†Èô§ÊåâÈíÆ
        const deleteButtonHtml = isBuiltIn ? '' : `<button class="system-prompt-delete-btn" onclick="event.stopPropagation(); deleteSystemPromptTemplate('${template.id}', ${isBuiltIn})">Delete</button>`;
        listHtml += `
          <div class="system-prompt-item" data-id="${template.id}" data-builtin="${isBuiltIn}">
            <div class="system-prompt-item-name">${escapeHtml(template.title)}</div>
            <div class="system-prompt-item-actions">
              ${deleteButtonHtml}
            </div>
          </div>
        `;
      });
      
      // Ê∑ªÂä†Ëá™ÂÆö‰πâÈÄâÈ°πÔºàÁî®‰∫éÊñ∞Âª∫Ëá™ÂÆö‰πâÔºâ
      listHtml += `
        <div class="system-prompt-item" data-id="custom-new" data-builtin="false" style="border-style: dashed; opacity: 0.8;">
          <div class="system-prompt-item-name">+ Create Custom</div>
        </div>
      `;
      
      systemPromptTemplateList.innerHTML = listHtml;
      
      // Ê∑ªÂä†ÁÇπÂáª‰∫ã‰ª∂ÁõëÂê¨Âô®
      systemPromptTemplateList.querySelectorAll('.system-prompt-item').forEach(item => {
        item.onclick = (e) => {
          if (!e.target.classList.contains('system-prompt-delete-btn')) {
            selectSystemPromptTemplate(item.dataset.id, item.dataset.builtin === 'true');
          }
        };
      });
      
      // ÁªüËÆ°ÂÜÖÁΩÆÂíåËá™ÂÆö‰πâÊ®°ÊùøÊï∞Èáè
      const builtInCount = templates.filter(t => t.is_builtin).length;
      const customCount = templates.filter(t => !t.is_builtin).length;
      let statusText = `${builtInCount} built-in personalities`;
      if (customCount > 0) {
        statusText += `, ${customCount} custom`;
      }
      templateStatus.textContent = statusText;
    } catch (e) {
      templateStatus.textContent = 'Failed to load: ' + e.message;
    }
  }
  
  // ËÆ°ÁÆóÂπ∂ÊòæÁ§∫system promptÁöÑtokenÊï∞
  function updateSystemPromptTokensInfo(content) {
    const tokensInfo = document.getElementById('system_prompt_tokens_info');
    if (!content) {
      tokensInfo.textContent = '';
      return;
    }
    // Ëøë‰ººËÆ°ÁÆótokenÊï∞Ôºà4Â≠óÁ¨¶‚âà1 tokenÔºâ
    const estimatedTokens = Math.ceil(content.length / 4);
    tokensInfo.textContent = `Current system prompt: ~${estimatedTokens} tokens`;
  }
  
  // ÈÄâÊã©Á≥ªÁªüÊèêÁ§∫Ê®°Êùø
  async function selectSystemPromptTemplate(templateId, isBuiltIn) {
    currentSelectedTemplateId = templateId;
    currentIsBuiltIn = isBuiltIn;
    
    // Êõ¥Êñ∞ÂàóË°®È°πÁöÑactiveÁä∂ÊÄÅ
    systemPromptTemplateList.querySelectorAll('.system-prompt-item').forEach(item => {
      item.classList.remove('active');
    });
    const selectedItem = systemPromptTemplateList.querySelector(`[data-id="${templateId}"]`);
    if (selectedItem) {
      selectedItem.classList.add('active');
    }
    
    if (templateId === 'custom-new') {
      // ÂàõÂª∫Êñ∞Ëá™ÂÆö‰πâ
      promptEditorSection.style.display = 'block';
      systemPromptInput.value = '';
      customPromptName.value = '';
      systemPromptStatus.textContent = 'Creating new custom personality...';
      updateSystemPromptTokensInfo('');
    } else {
      // Âä†ËΩΩ‰ªª‰ΩïÊ®°ÊùøÔºàÂÜÖÁΩÆÊàñËá™ÂÆö‰πâÔºâ
      await loadTemplateContent(templateId);
      promptEditorSection.style.display = 'block';  // ÊòæÁ§∫ÁºñËæëÂô®
    }
  }
  
  // Âä†ËΩΩÊåáÂÆöÊ®°ÊùøÂÜÖÂÆπ
  async function loadTemplateContent(templateId) {
    try {
      const data = await api(`/settings/system-prompt/templates/${templateId}`);
      
      if (data.status === 'success') {
        currentTemplateContent = data.content;
        systemPromptInput.value = data.content;
        customPromptName.value = data.title;
        systemPromptStatus.textContent = `Loaded: ${data.title}`;
        
        // Êõ¥Êñ∞system prompt tokensÊòæÁ§∫
        updateSystemPromptTokensInfo(data.content);
      } else {
        systemPromptStatus.textContent = 'Error: ' + (data.error || 'Unknown error');
      }
    } catch (e) {
      systemPromptStatus.textContent = 'Failed to load: ' + e.message;
    }
  }
  
  // Âà†Èô§Á≥ªÁªüÊèêÁ§∫Ê®°Êùø
  async function deleteSystemPromptTemplate(templateId, isBuiltIn) {
    const confirmed = await showConfirm(`Delete this personality template? This action cannot be undone.`);
    
    if (!confirmed) {
      return;
    }
    
    try {
      systemPromptStatus.textContent = 'Deleting...';
      const result = await api(`/settings/system-prompt/templates/${templateId}`, 'DELETE');
      
      if (result.status === 'success' || result.ok) {
        systemPromptStatus.textContent = '‚úì Personality deleted successfully';
        
        // ÈáçÊñ∞Âä†ËΩΩÊ®°ÊùøÂàóË°®
        await loadTemplatesList();
        
        // Ê∏ÖÁ©∫ÁºñËæëÂô®
        if (currentSelectedTemplateId === templateId) {
          promptEditorSection.style.display = 'none';
          systemPromptInput.value = '';
          customPromptName.value = '';
          currentSelectedTemplateId = null;
        }
      } else {
        systemPromptStatus.textContent = 'Error: ' + (result.error || 'Failed to delete');
      }
    } catch (e) {
      systemPromptStatus.textContent = 'Delete failed: ' + e.message;
    }
  }
  
  // Open system prompt window
  openSystemPromptBtn.onclick = async () => {
    systemPromptModal.classList.add('show');
    await loadTemplatesList();
    await loadSystemPrompt();
  };
  
  // Close system prompt window
  closeSystemPromptBtn.onclick = () => {
    systemPromptModal.classList.remove('show');
  };
  
  // Click modal background to close
  systemPromptModal.onclick = (e) => {
    if (e.target === systemPromptModal) {
      systemPromptModal.classList.remove('show');
    }
  };
  
  // Load system prompt from settings
  async function loadSystemPrompt() {
    try {
      const data = await api('/settings/system-prompt');
      const savedPrompt = data.system_prompt || '';
      
      if (savedPrompt) {
        systemPromptInput.value = savedPrompt;
      } else {
        systemPromptInput.value = '';
      }
    } catch (e) {
      systemPromptStatus.textContent = 'Failed to load: ' + e.message;
    }
  }
  
  // Save system prompt
  saveSystemPromptBtn.onclick = async () => {
    try {
      const contentToSave = systemPromptInput.value.trim();
      
      if (!contentToSave) {
        systemPromptStatus.textContent = 'Cannot save empty prompt';
        return;
      }
      
      systemPromptStatus.textContent = 'Saving...';
      
      // Check if we're creating a new custom or editing an existing one
      if (currentSelectedTemplateId === 'custom-new' || !currentSelectedTemplateId) {
        // Save new custom personality
        const saveResponse = await api('/settings/system-prompt/save-custom', 'POST', {
          title: customPromptName.value.trim() || 'My Custom Personality',
          content: contentToSave
        });
        
        if (saveResponse.status === 'success') {
          const personalityId = saveResponse.personality_id;
          const personalityTitle = saveResponse.title;
          
          // ‰øùÂ≠òÂà∞settings
          await api('/settings/system-prompt', 'POST', {
            system_prompt: contentToSave
          });
          
          // ÈáçÊñ∞Âä†ËΩΩÊ®°ÊùøÂàóË°®
          await loadTemplatesList();
          
          systemPromptStatus.textContent = `‚úì Saved: ${personalityTitle}`;
        } else {
          systemPromptStatus.textContent = 'Error: ' + (saveResponse.error || 'Unknown error');
        }
      } else {
        // Update existing template
        await api('/settings/system-prompt', 'POST', {
          system_prompt: contentToSave
        });
        
        systemPromptStatus.textContent = `‚úì Updated: ${customPromptName.value}`;
      }
      
      updateSystemPromptTokensInfo(contentToSave);
    } catch (e) {
      systemPromptStatus.textContent = 'Failed to save: ' + e.message;
    }
  };
  
  // Reset system prompt
  resetSystemPromptBtn.onclick = () => {
    if (confirm('Clear custom personality?')) {
      systemPromptInput.value = '';
      customPromptName.value = '';
      systemPromptStatus.textContent = 'Cleared (not saved yet)';
      updateSystemPromptTokensInfo('');
    }
  };

  // ==================== Conversations Modal Window ====================
  const conversationsModal = document.getElementById('conversations-modal');
  const openConversationsBtn = document.getElementById('open-conversations-window');
  const closeConversationsBtn = document.getElementById('close-conversations-modal');
  const conversationSearch = document.getElementById('conversation-search');
  const reloadConversationsBtn = document.getElementById('reload-conversations-btn');
  const newConversationBtn = document.getElementById('new-conversation-btn');
  
  // New UI elements in chat window
  const loadedConvHeader = document.getElementById('loaded-conv-header');
  const loadedConvFooter = document.getElementById('loaded-conv-footer');
  const loadedConvTitleHeader = document.getElementById('loaded-conv-title-header');
  const loadedConvMetaHeader = document.getElementById('loaded-conv-meta-header');
  const loadedConvMetaFooter = document.getElementById('loaded-conv-meta-footer');
  
  let conversationsList = [];
  let selectedConversationId = null;
  let currentLoadedConversation = null;  // Track currently loaded conversation
  
  // Open conversations window
  openConversationsBtn.onclick = () => {
    conversationsModal.classList.add('show');
    loadConversationsList();
  };
  
  // New conversation button - clear chat and start fresh
  newConversationBtn.onclick = async () => {
    conversationsModal.classList.remove('show');
    
    // Clear chat display
    chatlog.innerHTML = '';
    
    // Reset message tracking
    messageIndex = 0;
    messageMap.clear();
    
    // Hide loaded conversation UI
    loadedConvHeader.style.display = 'none';
    loadedConvFooter.style.display = 'none';
    
    // Reset loaded conversation tracker
    currentLoadedConversation = null;
    selectedConversationId = null;
    
    // Clear input box and focus
    const msgInput = document.getElementById('msg');
    if (msgInput) {
      msgInput.value = '';
      msgInput.disabled = false;
      msgInput.style.pointerEvents = 'auto';
      msgInput.style.opacity = '1';
      msgInput.focus();
    }
    
    // Update metadata
    meta.textContent = 'New conversation started';
    
    try {
      // Clear backend history
      await api('/clear-history', 'POST', { session_id: 'default' });
      console.log('[DEBUG] New conversation started');
    } catch (e) {
      console.warn('[DEBUG] Failed to clear backend history:', e.message);
    }
  };
  
  // Close conversations window
  closeConversationsBtn.onclick = () => {
    conversationsModal.classList.remove('show');
  };
  
  // Click modal background to close
  conversationsModal.onclick = (e) => {
    if (e.target === conversationsModal) {
      conversationsModal.classList.remove('show');
    }
  };
  
  // Reload conversations from conversations.json
  reloadConversationsBtn.onclick = async () => {
    const statusEl = document.getElementById('conversation-status');
    
    // Show custom confirm dialog
    const confirmed = await showConfirm('ÈáçÊñ∞Âä†ËΩΩÂàùÂßãËÅäÂ§©ËÆ∞ÂΩïÔºü');
    
    if (!confirmed) {
      return;
    }
    
    try {
      reloadConversationsBtn.disabled = true;
      reloadConversationsBtn.textContent = '‚è≥ Reloading...';
      statusEl.textContent = 'Reloading conversations from original file...';
      
      const result = await api('/engine-conversations/reload', { method: 'POST' });
      
      if (result.ok) {
        statusEl.textContent = '‚úì Conversations reloaded successfully';
        await loadConversationsList();
      } else {
        statusEl.textContent = 'Error: ' + (result.error || 'Failed to reload');
      }
    } catch (e) {
      statusEl.textContent = 'Failed to reload: ' + e.message;
    } finally {
      reloadConversationsBtn.disabled = false;
      reloadConversationsBtn.textContent = 'üîÑ Reload';
    }
  };

  // ==================== Upload Conversation Zip ====================
  const uploadZipBtn = document.getElementById('upload-conversation-zip-btn');
  const zipFileInput = document.getElementById('zip-file-input');

  uploadZipBtn.onclick = () => {
    zipFileInput.value = '';  // Reset so same file can be re-selected
    zipFileInput.click();
  };

  zipFileInput.onchange = async () => {
    const file = zipFileInput.files[0];
    if (!file) return;

    const statusEl = document.getElementById('conversation-status');

    // Confirm before uploading
    const confirmed = await showConfirm(`‰∏ä‰º†Âπ∂Ëß£Âéã "${file.name}"ÔºüËøôÂ∞ÜÂØºÂÖ•ÂØπËØùÊï∞ÊçÆ„ÄÇ`);
    if (!confirmed) return;

    try {
      uploadZipBtn.disabled = true;
      uploadZipBtn.textContent = '‚è≥ Uploading...';
      statusEl.textContent = `Uploading ${file.name}...`;

      const formData = new FormData();
      formData.append('file', file);

      const res = await fetch('http://127.0.0.1:8787/upload-conversation-zip', {
        method: 'POST',
        body: formData
      });

      if (!res.ok) throw new Error(await res.text());
      const result = await res.json();

      if (result.ok) {
        statusEl.textContent = `‚úì ${result.message}`;
        // Refresh the conversation list
        await loadConversationsList();
      } else {
        statusEl.textContent = 'Error: ' + (result.error || 'Upload failed');
      }
    } catch (e) {
      statusEl.textContent = 'Upload failed: ' + e.message;
    } finally {
      uploadZipBtn.disabled = false;
      uploadZipBtn.textContent = 'üì¶ Upload Zip';
    }
  };
  
  // Update title in both header and footer when user types
  loadedConvTitleHeader.oninput = () => {
    if (currentLoadedConversation) {
      currentLoadedConversation.title = loadedConvTitleHeader.value;
    }
  };
  
  // Helper function to save current conversation to file
  async function saveCurrentConversation() {
    const messages = [];
    let messageIndex = 0;
    chatlog.querySelectorAll('.bubble').forEach(bubble => {
      // Note: addBubble uses 'u' for user, 'a' for assistant
      const role = bubble.classList.contains('u') ? 'user' : 'assistant';
      
      // Extract only the message content, excluding token info div
      let content = bubble.textContent;
      
      // If this is an assistant message and there's a muted token div child, remove its text
      if (role === 'assistant') {
        const tokenDiv = bubble.querySelector('.muted');
        if (tokenDiv) {
          // Get text excluding the token div
          const textNodes = [];
          for (let child of bubble.childNodes) {
            if (child.nodeType === Node.TEXT_NODE) {
              textNodes.push(child.textContent);
            }
          }
          content = textNodes.join('').trim() || content.replace(tokenDiv.textContent, '').trim();
        }
      }
      
      messages.push({ 
        id: `msg_${messageIndex++}`,
        role, 
        content 
      });
    });
    
    if (messages.length === 0) {
      console.log('[DEBUG] No messages to save');
      return;
    }
    
    console.log('[DEBUG] Messages to save:', JSON.stringify(messages, null, 2));
    
    const title = loadedConvTitleHeader.value.trim() || `Conversation ${new Date().toLocaleString()}`;
    const conversationId = currentLoadedConversation?.conversation_id || `engine_${Date.now()}`;
    
    try {
      console.log('[DEBUG] Auto-saving conversation:', conversationId);
      
      const result = await api('/engine-conversations/save', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          conversation_id: conversationId,
          title: title,
          messages: messages
        })
      });
      
      if (result.ok) {
        currentLoadedConversation = {
          conversation_id: result.conversation_id,
          title: result.title,
          messages: messages
        };
        loadedConvTitleHeader.value = result.title;
        loadedConvMetaHeader.textContent = `ID: ${result.conversation_id}`;
        loadedConvMetaFooter.textContent = `üìù ${messages.length} messages | ‚úì Saved`;
        
        // Refresh the list
        await loadConversationsList();
        
        console.log('[DEBUG] Conversation auto-saved successfully');
      } else {
        console.error('[DEBUG] Failed to save:', result.error);
      }
    } catch (e) {
      console.error('[DEBUG] Failed to save:', e.message);
    }
  };
  
  // Search conversations
  let searchTimeout = null;
  conversationSearch.oninput = () => {
    clearTimeout(searchTimeout);
    searchTimeout = setTimeout(() => {
      loadConversationsList(conversationSearch.value.trim());
    }, 300);
  };
  
  // Load conversations list
  async function loadConversationsList(query = '') {
    const listEl = document.getElementById('conversation-list');
    const statusEl = document.getElementById('conversation-status');
    
    try {
      listEl.innerHTML = '<div class="muted" style="text-align:center; padding:30px;">Loading...</div>';
      
      // Use engine-conversations endpoint (read-write file)
      const url = query ? `/engine-conversations?query=${encodeURIComponent(query)}` : '/engine-conversations';
      const data = await api(url);
      conversationsList = data.conversations || [];
      
      if (conversationsList.length === 0) {
        listEl.innerHTML = '<div class="muted" style="text-align:center; padding:30px;">No conversations found</div>';
        statusEl.textContent = '';
        return;
      }
      
      listEl.innerHTML = conversationsList.map(conv => `
        <div class="conversation-item" data-id="${conv.conversation_id}">
          <div class="conversation-item-content">
            <div class="conversation-title">${escapeHtml(conv.title)}</div>
            <div class="conversation-meta">
              <span>Messages: ${conv.message_count}</span>
              <span>${conv.update_time ? formatDate(conv.update_time) : 'Unknown date'}</span>
            </div>
          </div>
          <div class="conversation-item-actions">
            <button class="delete-btn" onclick="event.stopPropagation(); deleteConversation('${conv.conversation_id}')">Delete</button>
          </div>
        </div>
      `).join('');
      
      statusEl.textContent = `Found ${conversationsList.length} conversations`;
      
      // Add click handlers
      listEl.querySelectorAll('.conversation-item').forEach(item => {
        item.onclick = () => selectConversation(item.dataset.id);
      });
      
    } catch (e) {
      listEl.innerHTML = `<div class="muted" style="text-align:center; padding:30px;">Failed to load: ${e.message}</div>`;
      statusEl.textContent = 'Error loading conversations';
    }
  }
  
  // Format timestamp to readable date
  function formatDate(timestamp) {
    const date = new Date(timestamp * 1000);
    return date.toLocaleDateString('en-US', { 
      year: 'numeric', 
      month: 'short', 
      day: 'numeric',
      hour: '2-digit',
      minute: '2-digit'
    });
  }
  
  // Select and load a conversation
  async function deleteConversation(conversationId) {
    if (!confirm('Are you sure you want to delete this conversation? This action cannot be undone.')) {
      return;
    }
    
    try {
      const statusEl = document.getElementById('conversation-status');
      statusEl.textContent = 'Deleting...';
      
      // For now, we can only delete using the available API
      // This is a client-side delete simulation - you may need to implement a backend delete endpoint
      const data = await api(`/engine-conversations/delete/${conversationId}`, {
        method: 'POST'
      });
      
      if (data.error) {
        statusEl.textContent = `Error: ${data.error}`;
        return;
      }
      
      // Reload conversations list
      loadConversationsList();
      statusEl.textContent = 'Conversation deleted';
      
      // If this was the selected conversation, clear preview
      if (selectedConversationId === conversationId) {
        const previewEl = document.getElementById('conversation-list').querySelector('.conversation-preview');
        if (previewEl) {
          previewEl.remove();
        }
        selectedConversationId = null;
      }
      
    } catch (e) {
      document.getElementById('conversation-status').textContent = `Delete failed: ${e.message}`;
    }
  }

  async function selectConversation(conversationId) {
    const statusEl = document.getElementById('conversation-status');
    const listEl = document.getElementById('conversation-list');
    
    // Highlight selected item
    listEl.querySelectorAll('.conversation-item').forEach(item => {
      item.style.borderColor = item.dataset.id === conversationId 
        ? 'rgba(80,120,255,.6)' 
        : 'rgba(255,255,255,.08)';
    });
    
    try {
      statusEl.textContent = 'Loading conversation...';
      
      // Use engine-conversations endpoint (read-write file)
      const data = await api(`/engine-conversations/${conversationId}`);
      
      if (data.error) {
        statusEl.textContent = data.error;
        return;
      }
      
      selectedConversationId = conversationId;
      
      // Show preview of messages
      const selectedItem = listEl.querySelector(`[data-id="${conversationId}"]`);
      
      // Remove existing preview
      const existingPreview = listEl.querySelector('.conversation-preview');
      if (existingPreview) {
        existingPreview.remove();
      }
      
      // Add preview below selected item
      const previewHtml = `
        <div class="conversation-preview">
          <div style="margin-bottom:10px; display:flex; justify-content:space-between; align-items:center;">
            <span class="muted">${data.messages.length} messages</span>
            <button id="load-to-chat" style="padding:6px 12px; font-size:12px; background:rgba(80,120,255,.3); border-color:rgba(80,120,255,.5);">Load to Chat</button>
          </div>
          ${data.messages.slice(0, 10).map(msg => `
            <div class="preview-message ${msg.role}">
              <div class="role">${msg.role}</div>
              <div>${escapeHtml(msg.content.substring(0, 300))}${msg.content.length > 300 ? '...' : ''}</div>
            </div>
          `).join('')}
          ${data.messages.length > 10 ? `<div class="muted" style="text-align:center; padding:10px;">... and ${data.messages.length - 10} more messages</div>` : ''}
        </div>
      `;
      
      selectedItem.insertAdjacentHTML('afterend', previewHtml);
      
      // Add load to chat handler
      document.getElementById('load-to-chat').onclick = () => {
        loadConversationToChat(data);
      };
      
      statusEl.textContent = `Loaded: ${data.title}`;
      
    } catch (e) {
      statusEl.textContent = `Failed to load: ${e.message}`;
    }
  }
  
  // Load conversation to main chat
  async function loadConversationToChat(conversationData) {
    const statusEl = document.getElementById('conversation-status');
    
    try {
      statusEl.textContent = 'Loading to chat context...';
      console.log('[DEBUG] Loading conversation to context:', conversationData.conversation_id);
      
      // Load to agent's context first
      const result = await api('/load-conversation-to-context', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          conversation_id: conversationData.conversation_id,
          session_id: 'default'
        })
      });
      
      console.log('[DEBUG] API response:', result);
      
      if (!result.ok) {
        statusEl.textContent = 'Warning: Failed to load to agent context: ' + (result.error || 'Unknown error');
        console.error('[DEBUG] Failed to load context:', result.error);
      } else {
        statusEl.textContent = `‚úì Loaded ${result.message_count} messages to context`;
      }
      
      // Clear current chat
      chatlog.innerHTML = '';
      
      // Reset message tracking
      messageIndex = 0;
      messageMap.clear();
      
      // Add messages to chat display
      conversationData.messages.forEach(msg => {
        if (msg.role === 'user' || msg.role === 'assistant') {
          addBubble(msg.content, msg.role === 'user' ? 'user' : 'assistant');
        }
      });
      
      // Update current loaded conversation tracker
      currentLoadedConversation = conversationData;
      
      // Show loaded conversation header and footer
      loadedConvHeader.style.display = 'block';
      loadedConvFooter.style.display = 'block';
      loadedConvTitleHeader.value = conversationData.title;
      loadedConvMetaHeader.textContent = `ID: ${conversationData.conversation_id}`;
      loadedConvMetaFooter.textContent = `üìù ${conversationData.messages.length} messages`;
      
      // Close modal
      conversationsModal.classList.remove('show');
      
      // Enable and focus input box
      const msgInput = document.getElementById('msg');
      if (msgInput) {
        msgInput.disabled = false;
        msgInput.style.pointerEvents = 'auto';
        msgInput.style.opacity = '1';
        msgInput.focus();
      }
      
      // Update meta
      meta.textContent = `Loaded: ${conversationData.title} (${conversationData.messages.length} messages) - Context synced`;
      
    } catch (e) {
      console.error('[DEBUG] Exception:', e);
      statusEl.textContent = 'Failed to load: ' + e.message;
      // Still show the messages even if context sync failed
      chatlog.innerHTML = '';
      conversationData.messages.forEach(msg => {
        if (msg.role === 'user' || msg.role === 'assistant') {
          addBubble(msg.content, msg.role === 'user' ? 'user' : 'assistant');
        }
      });
      conversationsModal.classList.remove('show');
      
      // Enable and focus input box even on error
      const msgInput = document.getElementById('msg');
      if (msgInput) {
        msgInput.disabled = false;
        msgInput.style.pointerEvents = 'auto';
        msgInput.style.opacity = '1';
        msgInput.focus();
      }
      
      meta.textContent = `Loaded: ${conversationData.title} (display only - context sync failed)`;
    }
  }

  // ==================== Memory Modal Window ====================
  // Open/close handlers for memory modal window
  const memoryModal = document.getElementById('memory-modal');
  const openMemoryBtn = document.getElementById('open-memory-window');
  const closeMemoryBtn = document.getElementById('close-memory-modal');
  
  // Open memory window
  openMemoryBtn.onclick = () => {
    memoryModal.classList.add('show');
    loadPlugins();
    loadMemory();
  };
  
  // Close memory window
  closeMemoryBtn.onclick = () => {
    memoryModal.classList.remove('show');
  };
  
  // Click modal background to close
  memoryModal.onclick = (e) => {
    if (e.target === memoryModal) {
      memoryModal.classList.remove('show');
    }
  };
  
  // ESC key to close modals
  document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape') {
      if (memoryModal.classList.contains('show')) {
        memoryModal.classList.remove('show');
      }
      if (conversationsModal.classList.contains('show')) {
        conversationsModal.classList.remove('show');
      }
      if (systemPromptModal.classList.contains('show')) {
        systemPromptModal.classList.remove('show');
      }
    }
  });

  // ==================== Memory Plugin System ====================
  
  let currentPluginId = null;
  let availablePlugins = [];
  
  // Tab switching functionality
  document.querySelectorAll('.tab-btn').forEach(btn => {
    btn.onclick = () => {
      document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
      document.querySelectorAll('.tab-content').forEach(c => c.style.display = 'none');
      btn.classList.add('active');
      document.getElementById(btn.dataset.tab + '-tab').style.display = 'block';
    };
  });

  // Load and display memories (two-list system)
  async function loadMemory() {
    const coreMemoryList = document.getElementById('core-memory-list');
    const memoryLibraryList = document.getElementById('memory-library-list');
    
    try {
      // Use visualization API
      const data = await api("/memory/visualization");
      
      // Display memory list (split into core and library based on importance)
      const memories = data.recent_memories || (data.memory_tree?.recent_memories) || [];
      
      // Core memory: importance >= 0.8 (memories marked as important)
      // Library: importance < 0.8
      const CORE_THRESHOLD = 0.8;
      
      const coreMemories = memories.filter(m => 
        ((m.effective_importance || m.importance) || 0) >= CORE_THRESHOLD
      );
      
      const libraryMemories = memories.filter(m => 
        ((m.effective_importance || m.importance) || 0) < CORE_THRESHOLD
      );
      
      // Display core memories
      if (coreMemories.length > 0) {
        coreMemoryList.innerHTML = coreMemories.map(m => `
          <div class="memory-item core-item" data-id="${m.id || m.content.substring(0,30)}" data-content="${escapeHtml(m.content)}">
            <div class="memory-content">${escapeHtml(m.content)}</div>
            <div class="memory-meta">
              <span>${new Date(m.timestamp).toLocaleDateString()}</span>
              <span style="color:#80d8ff; font-weight:600;">${((m.effective_importance || m.importance) * 100).toFixed(0)}%</span>
            </div>
          </div>
        `).join('');
        
        // Add context menu to core items
        coreMemoryList.querySelectorAll('.core-item').forEach(item => {
          item.oncontextmenu = (e) => showCoreMemoryContextMenu(e, item);
        });
      } else {
        coreMemoryList.innerHTML = '<div class="muted" style="text-align:center; padding:20px; font-size:12px;">No core memories yet</div>';
      }
      
      // Display memory library
      if (libraryMemories.length > 0) {
        memoryLibraryList.innerHTML = libraryMemories.map(m => `
          <div class="memory-item library-item" data-id="${m.id || m.content.substring(0,30)}" data-content="${escapeHtml(m.content)}">
            <div class="memory-content">${escapeHtml(m.content)}</div>
            <div class="memory-meta">
              <span>${new Date(m.timestamp).toLocaleDateString()}</span>
              <span style="opacity:0.6; font-size:11px;">${((m.effective_importance || m.importance) * 100).toFixed(0)}%</span>
            </div>
          </div>
        `).join('');
        
        // Add context menu to library items
        memoryLibraryList.querySelectorAll('.library-item').forEach(item => {
          item.oncontextmenu = (e) => showLibraryMemoryContextMenu(e, item);
        });
      } else {
        memoryLibraryList.innerHTML = '<div class="muted" style="text-align:center; padding:20px; font-size:12px;">Click refresh to load memories or add new ones below...</div>';
      }
      
    } catch (e) {
      coreMemoryList.innerHTML = `<div class="muted" style="text-align:center; padding:20px; font-size:12px;">Error: ${e.message}</div>`;
    }
  }
  
  // Core memory keywords for auto-detection (stricter matching with context awareness)
  const CORE_KEYWORDS = [
    // Áß∞ÂëºÁõ∏ÂÖ≥
    'ÂêçÂ≠ó', 'Âè´ÂÅö', 'Áß∞Âëº', 'ÊòµÁß∞', 'ÊàëÊòØ', 'ÊàëÂè´', 
    'my name', 'call me', 'i am', 'i\'m', 'my name is',
    // ËÅå‰∏öÁõ∏ÂÖ≥
    'ËÅå‰∏ö', 'Â∑•‰Ωú', 'ËÅå‰Ωç', 'ÊàëÁöÑÂ∑•‰Ωú', '‰ªªËÅå', 
    'job', 'work as', 'career', 'profession', 'employed',
    // ÂÆ∂Â∫≠ÂÖ≥Á≥ª
    'Â¶ªÂ≠ê', '‰∏àÂ§´', 'Â≠©Â≠ê', 'ÂÑøÂ≠ê', 'Â•≥ÂÑø', 'Áà∂‰∫≤', 'ÊØç‰∫≤', 'Áà∏Áà∏', 'Â¶àÂ¶à', 'ÂÆ∂‰∫∫',
    'wife', 'husband', 'son', 'daughter', 'father', 'mother', 'parent', 'family',
    // Ê†∏ÂøÉ‰∏™‰∫∫‰ø°ÊÅØ
    'Âπ¥ÈæÑ', 'ÁîüÊó•', 'Âá∫Áîü', 
    'age', 'born', 'birthday', 'years old',
    // ÂüéÂ∏Ç/Âú∞ÁÇπÔºà‰∏•Ê†ºÂåπÈÖçÔºåÈÅøÂÖç"from game"ËØØÂåπÈÖçÔºâ
    '‰ΩèÂú®', 'ÁîüÊ¥ªÂú®', 'Êù•Ëá™‰∫é', 
    'live in', 'live at', 'from', 'located in', 'living in', 'hometown', 'city:'
  ];
  
  // Exclusion patterns to avoid false positives
  const EXCLUSION_PATTERNS = [
    /from the game/i,
    /from a game/i,
    /from.*game/i,
    /from.*book/i,
    /from.*movie/i,
    /from.*show/i,
    /from.*series/i
  ];
  
  // Check if memory content matches core keywords (with stricter word boundary logic)
  function matchesCoreKeywords(content) {
    const lowerContent = content.toLowerCase();
    
    // First check exclusion patterns (false positive prevention)
    for (let pattern of EXCLUSION_PATTERNS) {
      if (pattern.test(lowerContent)) {
        return false;  // Exclude this memory from core
      }
    }
    
    // ‰ΩøÁî®ÂçïËØçËæπÁïåÂåπÈÖçÔºåÈÅøÂÖçÈÉ®ÂàÜÂçïËØçËØØÂåπÈÖç
    let matches = 0;
    CORE_KEYWORDS.forEach(keyword => {
      // ÂàõÂª∫Ê≠£ÂàôË°®ËææÂºèÔºå‰ΩøÁî®ÂçïËØçËæπÁïå(\b)
      const lowerKeyword = keyword.toLowerCase();
      
      // ÂØπ‰∫éËã±ÊñáÂÖ≥ÈîÆËØç‰ΩøÁî®ÂçïËØçËæπÁïåÊ≠£Âàô
      if (/^[a-z\s':\-]+$/.test(lowerKeyword)) {
        // Ëã±ÊñáÔºö‰ΩøÁî®ÂçïËØçËæπÁïå
        const regex = new RegExp(`\\b${lowerKeyword.replace(/\s+/g, '\\s+')}\\b`, 'g');
        if (regex.test(lowerContent)) {
          matches++;
        }
      } else {
        // ‰∏≠ÊñáÔºö‰ΩøÁî®includesÔºàÂõ†‰∏∫\bÂØπ‰∏≠ÊñáÊïàÊûú‰∏çÂ•ΩÔºâ
        if (lowerContent.includes(lowerKeyword)) {
          matches++;
        }
      }
    });
    
    return matches > 0;
  }
  
  // Context menu for CORE memory items (delete + move to library)
  function showCoreMemoryContextMenu(e, item) {
    e.preventDefault();
    
    // Remove existing context menu
    const existing = document.querySelector('.memory-context-menu');
    if (existing) existing.remove();
    
    const menu = document.createElement('div');
    menu.className = 'memory-context-menu';
    menu.style.cssText = `
      position: fixed;
      top: ${e.clientY}px;
      left: ${e.clientX}px;
      background: rgba(0,0,0,.85);
      border: 1px solid rgba(128,216,255,.3);
      border-radius: 6px;
      padding: 4px;
      z-index: 10000;
      box-shadow: 0 4px 12px rgba(0,0,0,.5);
    `;
    
    // Move to Library option
    const moveOption = document.createElement('div');
    moveOption.style.cssText = `
      padding: 8px 12px;
      font-size: 12px;
      color: #b3e5fc;
      cursor: pointer;
      border-radius: 4px;
      user-select: none;
    `;
    moveOption.textContent = 'üìö Move to Library';
    moveOption.onmouseover = () => moveOption.style.background = 'rgba(128,216,255,.15)';
    moveOption.onmouseout = () => moveOption.style.background = 'transparent';
    moveOption.onclick = () => {
      const libraryList = document.getElementById('memory-library-list');
      const clone = item.cloneNode(true);
      clone.classList.add('library-item');
      clone.oncontextmenu = (e) => showLibraryMemoryContextMenu(e, clone);
      
      // Remove muted placeholder if exists
      const placeholder = libraryList.querySelector('.muted');
      if (placeholder) placeholder.remove();
      
      libraryList.insertBefore(clone, libraryList.firstChild);
      item.remove();
      
      // Check if core list is empty
      const coreList = document.getElementById('core-memory-list');
      if (!coreList.querySelector('.memory-item')) {
        coreList.innerHTML = '<div class="muted" style="text-align:center; padding:20px; font-size:12px;">No core memories yet</div>';
      }
      
      console.log('[DEBUG] Moved memory to library:', item.dataset.content);
      menu.remove();
    };
    
    // Delete option
    const deleteOption = document.createElement('div');
    deleteOption.style.cssText = `
      padding: 8px 12px;
      font-size: 12px;
      color: #ff8080;
      cursor: pointer;
      border-radius: 4px;
      user-select: none;
    `;
    deleteOption.textContent = 'üóëÔ∏è Delete';
    deleteOption.onmouseover = () => deleteOption.style.background = 'rgba(255,80,80,.15)';
    deleteOption.onmouseout = () => deleteOption.style.background = 'transparent';
    deleteOption.onclick = async () => {
      if (!confirm('Delete this memory?')) {
        menu.remove();
        return;
      }
      
      const memoryId = item.dataset.id;
      try {
        await api('/memory/delete', 'POST', { memory_id: memoryId });
        console.log('[DEBUG] Deleted memory:', memoryId);
      } catch (err) {
        console.error('Failed to delete from backend:', err);
      }
      
      item.remove();
      
      // Check if core list is empty
      const coreList = document.getElementById('core-memory-list');
      if (!coreList.querySelector('.memory-item')) {
        coreList.innerHTML = '<div class="muted" style="text-align:center; padding:20px; font-size:12px;">No core memories yet</div>';
      }
      
      menu.remove();
    };
    
    menu.appendChild(moveOption);
    menu.appendChild(deleteOption);
    document.body.appendChild(menu);
    
    // Close menu on click elsewhere
    setTimeout(() => {
      document.addEventListener('click', (e) => {
        if (!e.target.closest('.memory-context-menu')) {
          menu.remove();
        }
      }, { once: true });
    }, 0);
  }
  
  // Context menu for LIBRARY memory items (move to core + delete)
  function showLibraryMemoryContextMenu(e, item) {
    e.preventDefault();
    
    // Remove existing context menu
    const existing = document.querySelector('.memory-context-menu');
    if (existing) existing.remove();
    
    const menu = document.createElement('div');
    menu.className = 'memory-context-menu';
    menu.style.cssText = `
      position: fixed;
      top: ${e.clientY}px;
      left: ${e.clientX}px;
      background: rgba(0,0,0,.85);
      border: 1px solid rgba(128,216,255,.3);
      border-radius: 6px;
      padding: 4px;
      z-index: 10000;
      box-shadow: 0 4px 12px rgba(0,0,0,.5);
    `;
    
    // Move to Core option
    const moveOption = document.createElement('div');
    moveOption.style.cssText = `
      padding: 8px 12px;
      font-size: 12px;
      color: #80d8ff;
      cursor: pointer;
      border-radius: 4px;
      user-select: none;
    `;
    moveOption.textContent = '‚≠ê Move to Core Memory';
    moveOption.onmouseover = () => moveOption.style.background = 'rgba(128,216,255,.15)';
    moveOption.onmouseout = () => moveOption.style.background = 'transparent';
    moveOption.onclick = () => {
      const coreList = document.getElementById('core-memory-list');
      const clone = item.cloneNode(true);
      clone.classList.remove('library-item');
      clone.classList.add('core-item');
      clone.oncontextmenu = (e) => showCoreMemoryContextMenu(e, clone);
      
      // Remove muted placeholder if exists
      const placeholder = coreList.querySelector('.muted');
      if (placeholder) placeholder.remove();
      
      coreList.insertBefore(clone, coreList.firstChild);
      item.remove();
      
      // Check if library list is empty
      const libraryList = document.getElementById('memory-library-list');
      if (!libraryList.querySelector('.memory-item')) {
        libraryList.innerHTML = '<div class="muted" style="text-align:center; padding:20px; font-size:12px;">No memories in library</div>';
      }
      
      console.log('[DEBUG] Moved memory to core:', item.dataset.content);
      menu.remove();
    };
    
    // Delete option
    const deleteOption = document.createElement('div');
    deleteOption.style.cssText = `
      padding: 8px 12px;
      font-size: 12px;
      color: #ff8080;
      cursor: pointer;
      border-radius: 4px;
      user-select: none;
    `;
    deleteOption.textContent = 'üóëÔ∏è Delete';
    deleteOption.onmouseover = () => deleteOption.style.background = 'rgba(255,80,80,.15)';
    deleteOption.onmouseout = () => deleteOption.style.background = 'transparent';
    deleteOption.onclick = async () => {
      if (!confirm('Delete this memory?')) {
        menu.remove();
        return;
      }
      
      const memoryId = item.dataset.id;
      try {
        await api('/memory/delete', 'POST', { memory_id: memoryId });
        console.log('[DEBUG] Deleted memory:', memoryId);
      } catch (err) {
        console.error('Failed to delete from backend:', err);
      }
      
      item.remove();
      
      // Check if library list is empty
      const libraryList = document.getElementById('memory-library-list');
      if (!libraryList.querySelector('.memory-item')) {
        libraryList.innerHTML = '<div class="muted" style="text-align:center; padding:20px; font-size:12px;">No memories in library</div>';
      }
      
      menu.remove();
    };
    
    menu.appendChild(moveOption);
    menu.appendChild(deleteOption);
    document.body.appendChild(menu);
    
    // Close menu on click elsewhere
    setTimeout(() => {
      document.addEventListener('click', (e) => {
        if (!e.target.closest('.memory-context-menu')) {
          menu.remove();
        }
      }, { once: true });
    }, 0);
  }
  
  // Add new memory handler (with keyword auto-detection for core)
  let addMemoryBtn = document.getElementById('add-memory');
  if (addMemoryBtn) {
    addMemoryBtn.onclick = async () => {
      const textarea = document.getElementById('new-memory');
      const memoryStatus = document.getElementById('memory-status');
      const content = textarea.value.trim();
      
      if (!content) {
        alert('Please enter memory content');
        return;
      }
      
      // Split by double newlines for multiple memories
      const memories = content
        .split('\n\n')
        .map(line => line.trim())
        .filter(line => line.length > 0);
      
      if (memories.length === 0) {
        alert('Please enter memory content');
        return;
      }
      
      try {
        let addedCount = 0;
        let coreCount = 0;
        
        for (const memory of memories) {
          const result = await api('/memory/add', 'POST', {
            content: memory,
            importance: 0.3  // Á¶ÅÁî®ÂÖ≥ÈîÆËØçÂåπÈÖçÔºåÂõ∫ÂÆö‰ΩøÁî®ÈªòËÆ§ÈáçË¶ÅÊÄß
            // importance: matchesCoreKeywords(memory) ? 0.85 : 0.3  // Â∑≤Á¶ÅÁî®ÂÖ≥ÈîÆËØçÂåπÈÖç
          });
          addedCount++;
          
          // Check if matches core keywords
          if (matchesCoreKeywords(memory)) {
            coreCount++;
          }
        }
        
        console.log('[DEBUG] Added', addedCount, 'memories,', coreCount, 'matched core keywords');
        
        // Clear textarea
        textarea.value = '';
        
        // Reload memory display
        await loadMemory();
        
        // Show status
        if (coreCount > 0) {
          memoryStatus.textContent = `‚úì Added ${addedCount} memories (${coreCount} auto-matched to Core)`;
        } else {
          memoryStatus.textContent = `‚úì Added ${addedCount} memories`;
        }
        
      } catch (e) {
        console.error('Failed to add memory:', e);
        alert('Failed to add memory: ' + e.message);
      }
    };
  }
  
  // Auto-select core memories using LLM (backend API)
  let autoSelectBtn = document.getElementById('auto-select-core');
  if (autoSelectBtn) {
    autoSelectBtn.onclick = async () => {
      const memoryStatus = document.getElementById('memory-status');
      const coreList = document.getElementById('core-memory-list');
      const libraryList = document.getElementById('memory-library-list');
      
      memoryStatus.textContent = 'ü§ñ Analyzing memories with AI (strict mode)...';
      autoSelectBtn.disabled = true;
      
      try {
        // Call backend LLM evaluation API
        const result = await api('/memory/evaluate', 'POST', {
          memory_ids: []  // Empty = evaluate all memories
        });
        
        console.log('[DEBUG] LLM evaluation result:', result);
        
        if (result.success) {
          memoryStatus.textContent = result.message;
          
          // Áõ¥Êé•Êõ¥Êñ∞ DOMÔºå‰ΩøÁî®ÂêéÁ´ØËøîÂõûÁöÑÊï∞ÊçÆ
          const coreMemories = result.core_memories || [];
          const libraryMemories = result.library_memories || [];
          
          // Ê∏ÖÁ©∫Âπ∂ÈáçÊñ∞Â°´ÂÖÖÊ†∏ÂøÉËÆ∞ÂøÜÂàóË°®
          coreList.innerHTML = '';
          if (coreMemories.length === 0) {
            coreList.innerHTML = '<div class="muted" style="text-align:center; padding:20px; font-size:12px;">No core memories</div>';
          } else {
            coreMemories.forEach(mem => {
              const item = document.createElement('div');
              item.className = 'core-item memory-item';
              item.dataset.id = mem.id;
              item.dataset.content = mem.content;
              item.textContent = mem.content;
              item.oncontextmenu = (e) => showCoreMemoryContextMenu(e, item);
              coreList.appendChild(item);
            });
          }
          
          // Ê∏ÖÁ©∫Âπ∂ÈáçÊñ∞Â°´ÂÖÖÂ∫ìËÆ∞ÂøÜÂàóË°®
          libraryList.innerHTML = '';
          if (libraryMemories.length === 0) {
            libraryList.innerHTML = '<div class="muted" style="text-align:center; padding:20px; font-size:12px;">No memories in library</div>';
          } else {
            libraryMemories.forEach(mem => {
              const item = document.createElement('div');
              item.className = 'library-item memory-item';
              item.dataset.id = mem.id;
              item.dataset.content = mem.content;
              item.textContent = mem.content;
              item.oncontextmenu = (e) => showLibraryMemoryContextMenu(e, item);
              libraryList.appendChild(item);
            });
          }
          
        } else {
          memoryStatus.textContent = '‚ùå ' + (result.message || 'Evaluation failed');
        }
        
      } catch (e) {
        console.error('Failed to auto-select:', e);
        memoryStatus.textContent = 'Auto-select failed: ' + e.message;
      } finally {
        autoSelectBtn.disabled = false;
      }
    };
  }

  function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  }

  document.getElementById('refresh-memory').onclick = () => {
    loadMemory();
  };

  // User Profile Save Handler
  document.getElementById('save-profile').onclick = () => {
    const name = document.getElementById('user_name').value.trim();
    const age = document.getElementById('user_age').value.trim();
    const gender = document.getElementById('user_gender').value;
    const occupation = document.getElementById('user_occupation').value.trim();
    const location = document.getElementById('user_location').value.trim();
    const bio = document.getElementById('user_bio').value.trim();
    
    // ‰øùÂ≠òÂà∞ localStorage
    const profileData = {
      name,
      age: age ? parseInt(age) : null,
      gender,
      occupation,
      location,
      bio,
      savedAt: new Date().toISOString()
    };
    
    localStorage.setItem('userProfile', JSON.stringify(profileData));
    
    // ÊòæÁ§∫‰øùÂ≠òÊàêÂäüÊèêÁ§∫
    const btn = document.getElementById('save-profile');
    const originalText = btn.textContent;
    btn.textContent = '‚úì Saved!';
    btn.style.background = 'rgba(100,200,100,.3)';
    btn.style.borderColor = 'rgba(100,200,100,.4)';
    
    setTimeout(() => {
      btn.textContent = originalText;
      btn.style.background = 'rgba(80,120,255,.3)';
      btn.style.borderColor = 'rgba(80,120,255,.4)';
    }, 2000);
  };
  
  // Load user profile on page init
  function loadUserProfile() {
    const profileData = localStorage.getItem('userProfile');
    if (profileData) {
      try {
        const profile = JSON.parse(profileData);
        document.getElementById('user_name').value = profile.name || '';
        document.getElementById('user_age').value = profile.age || '';
        document.getElementById('user_gender').value = profile.gender || '';
        document.getElementById('user_occupation').value = profile.occupation || '';
        document.getElementById('user_location').value = profile.location || '';
        document.getElementById('user_bio').value = profile.bio || '';
      } catch (e) {
        console.error('Failed to load user profile:', e);
      }
    }
  }
  
  // Get user profile for chat API
  function getUserProfile() {
    const profileData = localStorage.getItem('userProfile');
    if (profileData) {
      try {
        const profile = JSON.parse(profileData);
        // Âè™ËøîÂõûÊúâÂÄºÁöÑÂ≠óÊÆµ
        const result = {};
        if (profile.name) result.name = profile.name;
        if (profile.age) result.age = profile.age;
        if (profile.gender) result.gender = profile.gender;
        if (profile.occupation) result.occupation = profile.occupation;
        if (profile.location) result.location = profile.location;
        if (profile.bio) result.bio = profile.bio;
        return Object.keys(result).length > 0 ? result : null;
      } catch (e) {
        console.error('Failed to get user profile:', e);
        return null;
      }
    }
    return null;
  }
  
  // Load user profile when page loads
  loadUserProfile();

  // Clear all memories handler (if needed)
  let clearBtn = document.getElementById('clear-memory');
  if (clearBtn) {
    clearBtn.onclick = async () => {
      if (!confirm('Clear all memories?')) return;
      
      try {
        await api("/memory/clear", "POST");
        await loadMemory();
        // ÁÑ¶ÁÇπ‰øÆÂ§çÔºöÁ°Æ‰øùÂºÇÊ≠•Êìç‰ΩúÂÆåÊàêÂêéÊÅ¢Â§çÁÑ¶ÁÇπÂà∞‰∏ªËæìÂÖ•Ê°Ü
        setTimeout(() => {
          const msgInput = document.getElementById('msg');
          if (msgInput) {
            msgInput.focus();
          }
        }, 0);
      } catch (e) {
        console.error('Failed to clear:', e);
      }
    };
  }

  // Initialize on page load
  setTimeout(() => {
    loadMemory();
  }, 500);

  // changeLanguage is defined globally in <head> so inline onchange works

  // Listen for language changes to update dynamic content
  window.addEventListener('languageChanged', (event) => {
    const lang = event.detail.language;
    console.log('[UI] Language changed event received:', lang);
    // Êõ¥Êñ∞È°µÈù¢‰∏äÁöÑÂä®ÊÄÅÂÜÖÂÆπ
    // ‰æãÂ¶ÇÔºöÊõ¥Êñ∞ toast, Á°ÆËÆ§ÂØπËØùÁ≠â
  });
</script>
</body>
</html>
